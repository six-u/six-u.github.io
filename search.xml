<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS奇奇怪怪，运算符优先级和结合律</title>
    <url>/JS%E8%AF%AD%E6%B3%95/JS%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E5%BE%8B/</url>
    <content><![CDATA[<h2 id="一、虎狼代码"><a href="#一、虎狼代码" class="headerlink" title="一、虎狼代码"></a>一、虎狼代码</h2><h3 id="1、a-5-b-”3-14”-a-b-8-14"><a href="#1、a-5-b-”3-14”-a-b-8-14" class="headerlink" title="1、a=5;b=”3.14”;a+ +b  // 8.14"></a>1、a=5;b=”3.14”;a+ +b  // 8.14</h3><p>一元运算符 + 会将后面跟的字符串转换为数字，如果后面的字符串不能转换为数字，则转换为NaN<br>如果式子写为 a++b则会报错，因为 ++ 会被识别为 递增运算符 运算到 6”3.14”的时候就会报错。</p>
<h3 id="2、1-1-2"><a href="#2、1-1-2" class="headerlink" title="2、1 + - + + + -  + 1 // 2"></a>2、1 + - + + + -  + 1 // 2</h3><p>其实只有第一个＋ 号会被识别为数字相加，其他的加减号均被识别为一元操作符，其作用在这里为改变后面的操作数1的正负。</p>
<h3 id="3、let-c-“2-4”-d-1-d-c-d-c-d-c"><a href="#3、let-c-“2-4”-d-1-d-c-d-c-d-c" class="headerlink" title="3、let c = “2.4”, d = 1 ; d =+ c; d += c; d =+ c"></a>3、let c = “2.4”, d = 1 ; d =+ c; d += c; d =+ c</h3><p> d分别为 2.4、”12.4”。d+=c 表示 d = d+c，</p>
<h3 id="4、let-a-1-b-2-a-b-a-b-a-b-a-b"><a href="#4、let-a-1-b-2-a-b-a-b-a-b-a-b" class="headerlink" title="4、let a = 1,b=2; a +++b;a + ++b;a+++b;a + + + b"></a>4、let a = 1,b=2; a +++b;a + ++b;a+++b;a + + + b</h3><p>a +++b  ===  a + ++b<br>a+++b = a++ + b<br>a + + + b === a+b</p>
<h3 id="5、a-3-b-2-aba-aba"><a href="#5、a-3-b-2-aba-aba" class="headerlink" title="5、a=3,b=2; aba ; aba"></a>5、a=3,b=2; a<em>b</em>a ; a<strong>b</strong>a</h3><p>a<em>b</em>a  // 18<br>a<strong>b</strong>a = // 6561 =&gt; 3的8次方</p>
<h3 id="6、a-1-b-3-a-b"><a href="#6、a-1-b-3-a-b" class="headerlink" title="6、a=1,b=3; ++a**b"></a>6、a=1,b=3; ++a**b</h3><p>结果为 8 ，先计算 ++ 再计算 **</p>
<h2 id="二、优先级和结合律"><a href="#二、优先级和结合律" class="headerlink" title="二、优先级和结合律"></a>二、优先级和结合律</h2><h3 id="1-优先级"><a href="#1-优先级" class="headerlink" title="1. 优先级"></a>1. 优先级</h3><p>比如： a+b<em>c 先执行 b</em>c ，再执行 a+ (b*c)的结果<br>比如：(a+b)*c 先执行 a+b，再将 a+b 的结果与 c 相乘<br>比如上一段，a+++b 等价于 a++ +b，等价于 (a++) + b。说明 后置递增 优先级高于 前置递增，并且递增高于 加法。</p>
<p>常见优先级比较：</p>
<ol>
<li>递增(++)、递减(–)的优先级高于 幂(**)、 四则运算和取余(%)；其中后置递增（和递减）优先级大于前置递增（和递减）</li>
<li>幂(*<em>) 高于 加(+)、减(-)、乘(</em>)、除(/)、取余(%),乘(*)、除(/)、取余(%)大于加(+)、减(-)</li>
<li>一元加(+a)和一元减(-a) 竟然比正常的四则运算、幂(**)和取余(%)的优先级都高</li>
<li>比较运算符相等(==)、不相等(!=)、严格相等(===)、严格不相等(!==)的优先级低于四则运算和取余(%)，但是高于逻辑与(&amp;&amp;) 和 逻或(||)</li>
<li>逻辑与(&amp;&amp;) 和 逻或(||) 优先级较低，仅仅高于常见的三元运算符以及赋值、还有空值合并(??)、yield、逗号；但是 逻辑非(!) 优先级高于幂(**)</li>
<li>用于组合的括号的优先级最高</li>
<li>逗号优先级最低</li>
</ol>
<p>*其他参看文末搬运的表格</p>
<h3 id="2-结合律"><a href="#2-结合律" class="headerlink" title="2. 结合律"></a>2. 结合律</h3><p>当有多个具有相同优先级的运算符时，结合性的就会发挥作用。也就是说，结合律在遇到如上述第5点的时候就会很有用。其实就是，用来区别相同运算符，或者相同优先级的运算符，同时出现时谁优先的问题。</p>
<h4 id="2-1左结合（从左到右）"><a href="#2-1左结合（从左到右）" class="headerlink" title="2.1左结合（从左到右）"></a>2.1左结合（从左到右）</h4><p>表示优先级相同时左边的优先，比如：<br>a<em>b</em>c 和 a<em>b/c  均是先计算 a</em>b，然后再计算 a*b 的结果和 c 相乘或相除</p>
<h4 id="2-2右结合（从右到左）"><a href="#2-2右结合（从右到左）" class="headerlink" title="2.2右结合（从右到左）"></a>2.2右结合（从右到左）</h4><p>表示优先级相同时右边的优先，比如：<br>a<strong>b</strong>c  就是先计算 b 的 c 次方，然后再计算 a 的 ( b 的 c 次方) 次方</p>
<h4 id="2-3-tips：其实相对来说左结合比右结合多-得多"><a href="#2-3-tips：其实相对来说左结合比右结合多-得多" class="headerlink" title="2.3 tips：其实相对来说左结合比右结合多 得多"></a>2.3 tips：其实相对来说左结合比右结合多 得多</h4><p>需要注意的右结合的运算符：</p>
<ol>
<li>逻辑非(!)</li>
<li>一元加(+a)、一元减(-a)</li>
<li>前置递增(++i)、前置递减(–i)</li>
<li>幂(**)</li>
<li>三元运算符( ? : )</li>
</ol>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级 - JavaScript | MDN (mozilla.org)</a></p>
</li>
<li><p>优先级和结合律表格搬运：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符类型</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>21</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Grouping">分组</a></td>
<td>n/a（不相关）</td>
</tr>
<tr>
<td>20</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#dot_notation">成员访问</a></td>
<td>从左到右</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#bracket_notation">需计算的成员访问</a></td>
<td>从左到右</td>
<td>… [ … ]</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a>（带参数列表）</td>
<td>n/a</td>
<td>new … ( … )</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions">函数调用</a></td>
<td>从左到右</td>
<td>… (… )</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining">可选链（Optional chaining）</a></td>
<td>从左到右</td>
<td>?.</td>
</tr>
<tr>
<td>19</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a>（无参数列表）</td>
<td>从右到左</td>
</tr>
<tr>
<td>18</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators#increment">后置递增</a></td>
<td>n/a</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators#decrement">后置递减</a></td>
<td>… –</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_NOT">逻辑非 (!)</a></td>
<td>从右到左</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">按位非 (~)</a></td>
<td>~ …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unary_plus">一元加法 (+)</a></td>
<td>+ …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unary_negation">一元减法 (-)</a></td>
<td>- …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators#increment">前置递增</a></td>
<td>++ …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators#decrement">前置递减</a></td>
<td>– …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a></td>
<td>typeof …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void">void</a></td>
<td>void …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete">delete</a></td>
<td>delete …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></td>
<td>await …</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Exponentiation">幂 (**)</a></td>
<td>从右到左</td>
</tr>
<tr>
<td>15</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Multiplication">乘法 (*)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Division">除法 (/)</a></td>
<td>… / …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Remainder">取余 (%)</a></td>
<td>… % …</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition">加法 (+)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Subtraction">减法 (-)</a></td>
<td>… - …</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Left_shift">按位左移 (&lt;&lt;)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Right_shift">按位右移 (&gt;&gt;)</a></td>
<td>… &gt;&gt; …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">无符号右移 (&gt;&gt;&gt;)</a></td>
<td>… &gt;&gt;&gt; …</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Less_than">小于 (&lt;)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Less_than_or_equal">小于等于 (&lt;=)</a></td>
<td>… &lt;= …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Greater_than">大于 (&gt;)</a></td>
<td>… &gt; …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Greater_than_or_equal">大于等于 (&gt;=)</a></td>
<td>… &gt;= …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in">in</a></td>
<td>… in …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a></td>
<td>… instanceof …</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">相等 (==)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Inequality">不相等 (!=)</a></td>
<td>… != …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality">一致/严格相等 (===)</a></td>
<td>… === …</td>
<td></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_inequality">不一致/严格不相等 (!==)</a></td>
<td>… !== …</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_AND">按位与 (&amp;)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR">按位异或 (^)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_OR">按位或 (|)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_AND">逻辑与 (&amp;&amp;)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_OR">逻辑或 (||)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">空值合并 (??)</a></td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">条件（三元）运算符</a></td>
<td>从右到左</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators#assignment_operators">赋值</a></td>
<td>从右到左</td>
</tr>
<tr>
<td>2</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield">yield</a></td>
<td>从右到左</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*">yield*</a></td>
<td>yield* …</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator">逗号 / 序列</a></td>
<td>从左到右</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>优先级</tag>
        <tag>结合律</tag>
      </tags>
  </entry>
  <entry>
    <title>Set,WeakSet,Map,WeakMap</title>
    <url>/JS%E8%AF%AD%E6%B3%95/Set,WeakSet,Map,WeakMap/</url>
    <content><![CDATA[<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a><strong>是什么？</strong></h2><p>Set、WeakSet 、Map、 WeakMap 均是 ES6 新增的数据类型</p>
<h3 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h3><p>Set 对象允许你存储<strong>任何类型的唯一值</strong>，无论是原始值或者是对象引用。Set 对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set 中的元素只会出现一次，即 <strong>Set 中的元素是唯一的</strong>。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet:"></a>WeakSet:</h3><p>WeakSet 对象是一些<strong>对象值的集合</strong>, 并且其中的每个对象值都只能出现一次。在WeakSet 的集合中是唯一的。也即是说，WeakSet 是只能放对象值的 Set 集合,并且这个对对象值的引用是弱引用。</p>
<h3 id="Map："><a href="#Map：" class="headerlink" title="Map："></a>Map：</h3><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap:"></a>WeakMap:</h3><p>WeakMap 是 key 只能是 Object 类型的 Map。 原始数据类型 是不能作为 key 的（比如 Symbol）。并且用作 key 的 对象是**<a href="https://six-u.gitee.io/JS%E8%AF%AD%E6%B3%95/JS%E5%BC%BA%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8/">弱引用</a>**的。</p>
<p>注：Set 内部使用 Object.is() 方法来判断两个数据项是否相等，Map 则是使用 Object.is() 方法判断键是否相等</p>
<h2 id="有什么区别？"><a href="#有什么区别？" class="headerlink" title="有什么区别？"></a><strong>有什么区别？</strong></h2><h3 id="Set-WeakSet"><a href="#Set-WeakSet" class="headerlink" title="Set/WeakSet"></a><strong>Set/WeakSet</strong></h3><ol>
<li>Set可以存放任何类型的值（基本类型，引用类型），WeakSet只能存放引用类型的值</li>
<li>Set存放引用类型是强引用，WeakSet是弱引用</li>
<li>Set可以遍历，但因为WeakSet是弱引用，所以不能遍历</li>
</ol>
<h3 id="Map-WeakMap"><a href="#Map-WeakMap" class="headerlink" title="Map/WeakMap"></a><strong>Map/WeakMap</strong></h3><ol>
<li>Map的key可以是任意类型，WeakMap的key只能是对象</li>
<li>Map的key是强引用，WeakMap是弱引用</li>
<li>Map可以遍历，但因为WeakMap是弱引用，所以也不能遍历</li>
</ol>
<h3 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set/Map"></a><strong>Set/Map</strong></h3><ol>
<li>Set又称为集合，Map又称为字典，Set集合以[value,value]的形式存储数据，Map字典以[key,value]的形式存储数据</li>
<li>Set的键就是值，值就是键，Map的键是键，值是值。</li>
<li>可以将 Set 理解为 将 value 作为 key 的 Map</li>
</ol>
<h2 id="运用场景举例"><a href="#运用场景举例" class="headerlink" title="运用场景举例"></a><strong>运用场景举例</strong></h2><h3 id="Set：-1"><a href="#Set：-1" class="headerlink" title="Set："></a><strong>Set：</strong></h3><p>数组去重：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">arr = [...new <span class="built_in">Set</span>(arr)] <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map:"></a><strong>Map:</strong></h3><p>作为数据字典，存取速度更快，底层有优化，在频繁增删键值对的场景下表现更好。</p>
<h3 id="WeakSet-WeakMap"><a href="#WeakSet-WeakMap" class="headerlink" title="WeakSet/WeakMap:"></a><strong>WeakSet/WeakMap:</strong></h3><p>以DOM对象为弱引用键，保存相关数据，当DOM回收时，避免内存泄漏</p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>弱引用</tag>
        <tag>WeakSet</tag>
        <tag>WeakMap</tag>
        <tag>Set</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>JS强引用弱引用</title>
    <url>/JS%E8%AF%AD%E6%B3%95/JS%E5%BC%BA%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是强引用？"><a href="#什么是强引用？" class="headerlink" title="什么是强引用？"></a><strong>什么是强引用？</strong></h2><p>所谓强引用 (Strong  Reference) 就是我们<strong>常见的普通对象引用</strong>，只要还有强引用指向一个对象，就能表明对象还活着。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;<span class="comment">/*some properties*/</span>&#125;</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> boss = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>以上student 、employee 、boss 等变量对对象的引用，均为<strong>强引用</strong></p>
<p><strong>特点：强引用的对象在js中不会被<a href="https://six-u.gitee.io/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></strong></p>
<h2 id="什么是弱引用？"><a href="#什么是弱引用？" class="headerlink" title="什么是弱引用？"></a><strong>什么是弱引用？</strong></h2><p>网上有个例子：</p>
<blockquote>
<p>强引用就是一个小孩A牵着一条狗，他们之间通过狗链儿连着</p>
<p>弱引用就是，旁边有个小孩B指着A牵的狗，说：嘿，那有条狗，B指向那条狗，但他们之间没有是指绑在一起的东西</p>
<p>当A放开狗链，狗就会跑掉（被垃圾回收），无论B是不是还指着</p>
<p>但是，当B不再指着那条狗，狗还被A牵着，不会影响它是否跑掉</p>
</blockquote>
<p>也即是说，如果在使用引用计数方式的垃圾回收策略的浏览器中，可以看作当产生一个弱引用时，计数并不会加1。</p>
<h2 id="js中弱引用的例子"><a href="#js中弱引用的例子" class="headerlink" title="js中弱引用的例子"></a><strong>js中弱引用的例子</strong></h2><p>在JS中，ES6新增的 <a href="https://six-u.gitee.io/JS%E8%AF%AD%E6%B3%95/Set,WeakSet,Map,WeakMap/">WeakMap 和 WeakSet</a> 给我们提供了部分弱引用的能力，其中WeakMap接受引用类型的 key，WeakSet接受只接受引用类型的值，以下时MDN的描述：</p>
<p>WeakSet 对象允许你将弱保持对象存储在一个集合中。</p>
<p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<p><strong>当然真正实现弱引用的API 其实是 WeakRef对象</strong></p>
<p>​    WeakRef对象包含对对象的弱引用，这个弱引用被称为该WeakRef对象的target或者是referent。对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为。而与此相反的，一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，JavaScript引擎GC才会销毁该对象并且回收该对象所占的内存空间。如果上述情况发生了，那么你就无法通过任何的弱引用来获取该对象。</p>
<p><strong>参考</strong></p>
<blockquote>
<p><a href="https://v8.dev/features/weak-references">Weak references and finalizers · V8</a></p>
<p><a href="https://www.infoq.cn/article/lKsmb2tlGH1EHG0*bbYg">如何实现JS真正意义上的弱引用？-InfoQ</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">WeakRef - JavaScript | MDN (mozilla.org)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>强引用</tag>
        <tag>弱引用</tag>
        <tag>垃圾回收</tag>
        <tag>WeakSet</tag>
        <tag>WeakMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JS内存泄漏</title>
    <url>/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是js内存泄露"><a href="#什么是js内存泄露" class="headerlink" title="什么是js内存泄露"></a><strong>什么是js内存泄露</strong></h2><p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>通俗理解就是：</p>
<p>程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。所以，<strong>对于不再用到的内存，没有及时释放，就叫做内存泄漏</strong></p>
<h2 id="造成内存泄露的常见情况"><a href="#造成内存泄露的常见情况" class="headerlink" title="造成内存泄露的常见情况"></a><strong>造成内存泄露的常见情况</strong></h2><p>1、意外的全局变量引起的内存泄漏</p>
<p>原因：全局变量，不会被回收。</p>
<p>解决：使用严格模式避免</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span> <span class="comment">// 解决方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b = <span class="string">&quot;some variable&quot;</span>  <span class="comment">// b未声明，被赋值为window的属性，变为全局变量  //严格模式下报错</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>2、DOM操作中闭包引起的内存泄漏</p>
<p>原因：闭包可以维持函数内局部变量，使其得不到释放。</p>
<p>解决：定义事件处理函数的外部函数中，删除对DOM的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">some</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    ele.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do sth...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele = <span class="literal">null</span>  <span class="comment">// 解决方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、被遗忘的定时器或者回调</p>
<p>原因：定时器中有DOM的引用，即使DOM删除了，但是定时器还在，所以内存中还是有这个DOM。</p>
<p>解决：手动删除定时器和DOM</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do sth...</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do sth...</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">window</span>.clearInterval(timer)</span><br></pre></td></tr></table></figure>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a><strong>如何检测</strong></h2><p>使用Chrome 控制台 Memory 以及 Performance 面板</p>
]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
        <tag>Memory</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>JS垃圾回收</title>
    <url>/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a><strong>内存泄露</strong></h2><p>程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。所以，<strong>对于不再用到的内存，没有及时释放，就叫做<a href="https://six-u.gitee.io/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存泄漏</a></strong></p>
<h2 id="什么是垃圾回收？"><a href="#什么是垃圾回收？" class="headerlink" title="什么是垃圾回收？"></a><strong>什么是垃圾回收？</strong></h2><p>不再继续使用的变量就是垃圾，垃圾还占用着内存造成内存泄露，所以垃圾需要回收，也就是不使用的内存需要回收以便之后使用。所以<strong>垃圾回收是一种内存管理机制</strong>。垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存</p>
<h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a><strong>js的垃圾回收机制</strong></h2><p>Javascript 具有自动垃圾回收机制 (GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>JavaScript 垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<h2 id="js垃圾回收原理"><a href="#js垃圾回收原理" class="headerlink" title="js垃圾回收原理"></a><strong>js垃圾回收原理</strong></h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="*标记清除"></a>*<strong>标记清除</strong></h3><p><strong>原理：</strong>当变量进入执行环境（如在函数中声明一个变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量</p>
<p><strong>绝大多数现代浏览器使用此方式进行垃圾回收。</strong></p>
<p><strong>执行过程</strong>：JavaScript 中有个全局对象，浏览器中是 window。垃圾收集器将定期从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象，一直进行下去，并对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。</p>
<p>标记阶段</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/biaoji.png"></p>
<p>清除阶段</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/clearprocess.png"></p>
<p><strong>缺点：</strong></p>
<ol>
<li>标记的效率太慢了，我们的垃圾回收需要时时刻刻去遍历检查每一个引用，如果你的js代码中对象太多，会导致非常严重的效率问题</li>
<li>浏览器在标记的过程中js是不能执行的，我们不能让垃圾回收拖慢我们js运行的时间</li>
</ol>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="*引用计数"></a>*<strong>引用计数</strong></h3><p>机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。</p>
<p>这种方式常常会引起内存泄漏（循环引用时），低版本的IE使用这种方式</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/yinyongjs.png"></p>
<p><strong>缺点：</strong></p>
<ol>
<li>A 和 B 循环引用，就算没有其他地方引用A或B,A/B的计时器都至少为1，不会被回收，造成内存泄露</li>
<li>变量的计数器一直计数，所以需要一直占用一定的空间，直到变量被回收，增加了内容占用</li>
</ol>
<p><img src="https://gitee.com/six-u/gallery/raw/master/xunhuanyinyong.png"></p>
<h2 id="js垃圾回收（标记清除）相关优化"><a href="#js垃圾回收（标记清除）相关优化" class="headerlink" title="js垃圾回收（标记清除）相关优化"></a><strong>js垃圾回收（标记清除）相关优化</strong></h2><h3 id="分代回收（Generation-GC）："><a href="#分代回收（Generation-GC）：" class="headerlink" title="分代回收（Generation GC）："></a><strong>分代回收（Generation GC）：</strong></h3><p>通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时</p>
<p>例如：V8将内存分为新生代和老生代，新生代中对象存活时间较短；老生代的对象存活时间较长或常驻内存</p>
<p><strong>Scavenge 算法</strong>：在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收。</p>
<p><strong>Cheney算法</strong>：Scavenge 算法的主要内部实现，Cheney 算法将堆内存一分为二，一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间。分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，将其复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理。还有一种情况是，如果复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中。</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/cheneysca.png"></p>
<p><strong>标记-清除和标记-整理算法：</strong>在分代的基础上，对老生代使用此算法。标记清楚后会留下不连续的内存空间，使用标记整理解决这一问题。<strong>标记-整理**</strong>由于需要移动对象，执行速度不会太快，所以在取舍上，V8主要使用**<strong>标记-清除**</strong>，当内存不足以分配时才会采用**<strong>标记-整理</strong></p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/markcompase.png"></p>
<h3 id="增量标记-GC"><a href="#增量标记-GC" class="headerlink" title="增量标记 GC"></a><strong>增量标记 GC</strong></h3><p>全停顿（stop-the-world）：</p>
<p>为了避免js应用逻辑和垃圾回收器看到不一样的情况，前面三种垃圾回收算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑。这种行为被称为全停顿。</p>
<p>在上述V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代恰恰相反，全停顿很肯能导致页面卡顿。</p>
<p>所以，为了降低全堆垃圾回收带来的停顿时间，V8在标记时采用增量标记（incremental marking），即<strong>将标记拆分为许多小步进，每一个步进完成时，就让js逻辑执行一小会</strong>。<strong>垃圾回收和逻辑执行交替进行，直到标记阶段完成</strong>。而后续的清理和整理也分别采用延迟清理（lazy sweeping）和增量整理（incremental compact</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/incremental_marking.png"></p>
<p>参考：</p>
<blockquote>
<p>​    <a href="https://zhuanlan.zhihu.com/p/113296268">v8垃圾回收机制</a></p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/23992332">JavaScript 中的垃圾回收</a></p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/353346756">浅析JS垃圾回收机制</a></p>
<p>​    <a href="https://www.jb51.net/article/162416.htm">深入理解 JS 垃圾回收</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
        <tag>内存泄漏</tag>
        <tag>标记清楚</tag>
        <tag>引用计数</tag>
      </tags>
  </entry>
  <entry>
    <title>six-u blog 加载速度优化</title>
    <url>/Project/six-u%20blog%20%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>偶然注意到，网站图非一般的大，严重影响首次渲染。对于一个静态页来说，实在有点说不过去。</p>
<p><strong>首先优化图片</strong></p>
<p>优化方式：</p>
<ol>
<li><p>缩小首屏使用到的图片大小</p>
</li>
<li><p>使用 manifest 缓存图片、css 等基本不会改变资源</p>
</li>
</ol>
<p>压缩前，主要占用下载的就是图片</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/clipboard.png"></p>
<p>压缩后，虽然还是图片消耗最大，但整体耗时减小了很多</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/clipboard1.png"></p>
<p>压缩前，Largest Contentful Paint (LCP) 最大内容绘制时间 为 3.1 秒</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/lcp1.png"></p>
<p>压缩后，Largest Contentful Paint (LCP) 最大内容绘制时间 为 2.0 秒，LCP 减少三分之一</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/lcp2.png"></p>
<p><strong>精简不必要内容</strong></p>
<p>然后去除 hexo ocean 主题中本站未使用的功能，如</p>
<ol>
<li><p>去掉图库 Gallery 及对应 ejs、jquery</p>
</li>
<li><p>去掉灯箱效果 fancyBox 及对应的 ejs、jquery</p>
</li>
<li><p>去掉 banner 图 js 过渡效果代码 load.js</p>
</li>
<li><p>去掉无用的 iconfont 等</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title>块语句中的函数声明</title>
    <url>/JS%E8%AF%AD%E6%B3%95/%E5%9D%97%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h2 id="一道题："><a href="#一道题：" class="headerlink" title="一道题："></a><strong>一道题：</strong></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  a = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="简单理解："><a href="#简单理解：" class="headerlink" title="简单理解："></a><strong>简单理解：</strong></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 0. 当前词法环境（blockEnv）中存在一个名为`a`的函数</span></span><br><span class="line">  <span class="comment">//  - 函数`a`已提升到当前块作用域的顶端声明和绑定</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line">  <span class="comment">// 1. 隐式提升到全局，是一个未绑定值的标识符`a`（相当于`var a`的效果）</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line">  <span class="comment">// 1. 隐式提升到全局，是一个未绑定值的标识符`a`（相当于`var a`的效果）</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2. 在执行上述声明语句之后：</span></span><br><span class="line">  <span class="comment">//  - a的值隐式地绑定到了全局的同名变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文字原理解释："><a href="#文字原理解释：" class="headerlink" title="文字原理解释："></a><strong>文字原理解释：</strong></h2><ul>
<li>在支持 Web 特性扩展（Web Legacy Compatibility Semantics）的引擎中，具名函数声明语句会被提升到它所在的块级作用域的初始化阶段来完成声明和绑定</li>
<li>该声明会 <strong>隐式地 向它所在的最外层可执行结构(函数或全局)添加同名变量</strong>，缺省值为 undefined</li>
<li>在<strong>执行函数声明语句</strong>时，该函数名的<strong>当前值</strong>还将<strong>隐式地</strong> <strong>动态提升到(或称为绑定到上述)可执行结构的变量环境中的</strong> 该同名变量。</li>
</ul>
<p><strong>注：</strong></p>
<p><strong>Web 特性扩展</strong>——ECMAScript 6 之后的规范中增加的一个补充提案（兼容性扩展规范），它们并不是 “严格的 ECMAScript 规范” 的一部分，而是用来解释历史问题、兼容问题的扩展部分</p>
<h3 id="强制性"><a href="#强制性" class="headerlink" title="强制性"></a><strong>强制性</strong></h3><p>这里有两个隐式的过程，并且这两个隐式过程是对于<strong>最外层可执行结构(函数或全局)是强制型</strong>的。<strong>并且提升的总是变量 a 的当前值（而不一定是它所声明的函数实例）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 最外层可执行结构(函数或全局)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="comment">// 已重写</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// `function`</span></span><br></pre></td></tr></table></figure>
<h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a><strong>影响范围</strong></h3><p>但是如果上层环境有相同的词法名字（<strong>let/const 名字</strong>），那么由于由于 let 和 const 的特性，此时全局环境不能再创建 同名变量名，也就不能提升上来了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>; <span class="comment">// 同样是块级，并且let 存在暂时性锁区，let a 后不能再 var 一个 a</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="comment">// 未重写</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a, a); <span class="comment">// `number`， 100 // 变量名不存在</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">global</span>, <span class="string">&quot;a&quot;</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="参考引用："><a href="#参考引用：" class="headerlink" title="参考引用："></a><strong>参考引用：</strong></h3><p>微信公众号：<a href="https://mp.weixin.qq.com/s/0CI53KqjzkEfPp7FvC-GcQ">印记中文-《一文读懂块语句中的函数声明》</a></p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>web特性扩展</tag>
        <tag>函数声明</tag>
        <tag>声明提升</tag>
        <tag>函数声明提升</tag>
        <tag>块级作用域</tag>
        <tag>词法环境</tag>
        <tag>变量环境</tag>
        <tag>动态提升</tag>
        <tag>兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Comet服务器推送</title>
    <url>/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Comet%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h1 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a><strong>Comet</strong></h1><p>Comet 是一种高级的 Ajax 技术，实现了服务器向页面实时推送数据的技术，应用场景有体育比赛比分和股票报价等。</p>
<h2 id="实现-Comet-有两种方式"><a href="#实现-Comet-有两种方式" class="headerlink" title="实现 Comet 有两种方式"></a><strong>实现 Comet 有两种方式</strong></h2><h3 id="长轮询："><a href="#长轮询：" class="headerlink" title="长轮询："></a><strong>长轮询：</strong></h3><p>长轮询是短轮询的翻版，</p>
<p>短轮询的方式是：页面定时向服务器发送请求，看有没有更新的数据。</p>
<p>长轮询的方式是：页面向服务器发起一个请求，服务器一直保持 TCP 连接打开，知道有数据可发送。发送完数据后，页面关闭该连接，随即又发起一个新的服务器请求，在这一过程中循环。</p>
<p><strong>短轮询和长轮询的区别是：</strong></p>
<p>短轮询中服务器对请求立即响应，而长轮询中服务器等待新的数据到来才响应，因此实现了服务器向页面推送实时，并减少了页面的请求次数。</p>
<p>长轮询 Ajax 实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHTTPRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    result = xhr.responseText;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;test2.php&quot;</span>); <span class="comment">//在获得数据后重新向服务器发起请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;test2.php&quot;</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="HTTP-流"><a href="#HTTP-流" class="headerlink" title="HTTP 流"></a><strong>HTTP 流</strong></h3><p>HTTP 流不同于上述两种轮询，因为它在页面整个生命周期内只使用一个 HTTP 连接。</p>
<p><strong>具体使用方法：</strong>即页面向浏览器发送一个请求，而服务器保持 TCP 连接打开，然后不断向浏览器发送数据。</p>
<p>HTTP 流的 Ajax 实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHTTPRequest();</span><br><span class="line">received = <span class="number">0</span>;	<span class="comment">//最新消息在响应消息的位置</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">3</span>)&#123;</span><br><span class="line">        result = xhr.responseText.substring(received);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        received += result.length;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;完成消息推送&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;test1.php&#x27;</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>Comet</tag>
        <tag>Ajax</tag>
        <tag>长轮询</tag>
        <tag>短轮询</tag>
        <tag>HTTP流</tag>
      </tags>
  </entry>
  <entry>
    <title>http请求在网络协议层面的走向流程</title>
    <url>/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/http%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E9%9D%A2%E7%9A%84%E8%B5%B0%E5%90%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="简要流程"><a href="#简要流程" class="headerlink" title="简要流程"></a>简要流程</h2><ol>
<li>通过 DNS 域名解析由域名获得服务器 IP 地址</li>
<li>通过 IP 寻址找到目标服务器</li>
<li>通过 TCP 协议建立链接</li>
<li>通过 HTTP 协议发送业务数据</li>
</ol>
<h2 id="一、寻址"><a href="#一、寻址" class="headerlink" title="一、寻址"></a>一、寻址</h2><h3 id="1-DNS-域名解析获取目标服务器-IP"><a href="#1-DNS-域名解析获取目标服务器-IP" class="headerlink" title="1. DNS 域名解析获取目标服务器 IP"></a>1. DNS 域名解析获取目标服务器 IP</h3><ol>
<li>查看浏览器是否缓存域名对应 IP</li>
<li>查看本机是否缓存，可通过在 cmd 中输入 ipconfig /displaydns 查看</li>
<li>查看本机 host 文件，win：C:\Windows\System32\drivers\etc\ hosts</li>
<li>查询本地域名解析服务器，即在本机网络配置中配置的 dns(配置 IP 的地方)。如：本地局域网网关的缓存，或者直接是电信等运行商部署在当地的 nds 服务器的缓存</li>
<li>查询 DNS 根域名解析服务器，根服务器只保存其下一级域名服务器地址，于是分发给下一级的顶级服务器</li>
<li>查询顶级服务器</li>
<li>查询二级服务器</li>
<li>以此类推，最终获得 IP 地址。</li>
<li>注：以上任意一步找到 IP，都会直接返回本机，不再向下查询。</li>
</ol>
<h3 id="2-IP-寻址找到目标服务器"><a href="#2-IP-寻址找到目标服务器" class="headerlink" title="2. IP 寻址找到目标服务器"></a>2. IP 寻址找到目标服务器</h3><ol>
<li>通过IP协议找到目标服务器，IP 协议的目的是实现网络层的数据转发，它通过路由器不断跳转，最终把数据成功送达目的地。</li>
<li>发送一个 IP 请求的过程：<ol>
<li>构建 IP 请求头</li>
<li>IP 协议通过 IP 寻址算法，找出一条通往目标服务器的路线</li>
<li>IP 寻址算法其实就是一种最短路径算法，两种实现：<ol>
<li>RIP 协议（确保 IP 路由跳转的次数最小）</li>
<li>OSPF 协议（确保 IP 路由跳转的速度最快）</li>
</ol>
</li>
</ol>
</li>
<li>发送端查询路由表，找出下一跳 （一般就是路由器） 的 IP 地址，并发送数据</li>
<li>路由器查询路由表，继续找出下一跳的 IP 地址，并发送数据，</li>
<li>如此往复，直到找到目的服务器，发送数据。</li>
</ol>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/http1.png" alt="image"></p>
<ol start="3">
<li>Mac 寻址找到服务器硬件接口<ol>
<li>IP 协议主要是用来寻找最优路径的，具体的传输是由以太网协议来做的</li>
<li>以太网属于数据链路层，它主要负责相邻设备的通信。原理是通过查询交换机 Mac 表，找到通信双方的物理接口，进而开始通信。</li>
</ol>
</li>
<li>通过有线网络或无线网络箱服务器硬件接口传输比特信息，光纤：光信号，电缆：电信号</li>
</ol>
<h2 id="二、建立-TCP-链接"><a href="#二、建立-TCP-链接" class="headerlink" title="二、建立 TCP 链接"></a>二、建立 TCP 链接</h2><ol>
<li><p>找到目标服务器后，通过 TCP 3 次握手建立连接</p>
</li>
<li><p>TCP 报文头</p>
</li>
</ol>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/http2.png"></p>
<ol start="3">
<li>TCP 三次握手过程</li>
</ol>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/http3.png"></p>
<ol start="4">
<li>每一次 TCP 握手以及数据交互，都是通过 IP 协议去传输的</li>
</ol>
<h2 id="三-发送数据"><a href="#三-发送数据" class="headerlink" title="三. 发送数据"></a>三. 发送数据</h2><h3 id="1-建立安全层-SSL"><a href="#1-建立安全层-SSL" class="headerlink" title="1. 建立安全层 SSL"></a>1. 建立安全层 SSL</h3><ol>
<li><p>发送一个 HTTPS 的请求，所以在发送数据之前，会创建一个 SSL 安全层，用于数据加密。</p>
<ol>
<li>对称加密</li>
<li>非对称加密</li>
</ol>
</li>
<li><p>目前方案：先使用非对称加密，进行秘钥协商，让通信双方拿到相同的钥匙。 然后使用对称加密，进行加密传输。</p>
<ol>
<li><p>密钥协商过程：</p>
<p> <img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/http4.png"></p>
</li>
<li><p>说明：</p>
<ol>
<li>客户端发送自身支持的加密算法。</li>
<li>服务器端选择一种加密算法，同时返回数字证书。</li>
<li>客户端确认证书有效。</li>
<li>客户端生成随机数，并使用证书中的服务器公钥加密，然后发送给服务器。</li>
<li>服务器端使用私钥解密，获得随机数。</li>
<li>双方使用第 2 步确定的加密算法，把随机数进行加密，即可获得相同的对称加密秘钥。</li>
</ol>
</li>
</ol>
</li>
<li><p>数字证书确保密钥协商是与服务端通信，而非中间人。</p>
<p> !<img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/http5.png"></p>
<p> <img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/http6.png"></p>
</li>
<li><p> 秘钥协商之后，SSL 安全层就建好了</p>
</li>
</ol>
<h3 id="2-发送-http-请求"><a href="#2-发送-http-请求" class="headerlink" title="2. 发送 http 请求"></a>2. 发送 http 请求</h3><ol>
<li>HTTP 协议其实就是制定了一个通信规则，规定了客户端和服务器之间的通信格式。</li>
<li>发起 HTTP 请求时，必须遵守以下规则：<ol>
<li>请求方法（必填） GET</li>
<li>请求地址（必填） /</li>
<li>HTTP 协议版本（必填） 1.1</li>
<li>其他 HTTP 头部字段（可选） Host、User-Agent、Accept</li>
<li>请求参数，放在空行后面（可选）</li>
</ol>
</li>
<li>服务器响应请求时，同样遵守了 HTTP 响应规则：<ol>
<li>HTTP 协议版本（必填） 1.1</li>
<li>响应状态码（必填） 200</li>
<li>状态码描述（必填） OK</li>
<li>其他 HTTP 头部字段（可选） Date、Server、ETag、Last-Modified 等</li>
<li>请求参数，放在空行后面（可选）</li>
</ol>
</li>
<li>只要我们遵守这个规则，就能进行 HTTP 通信了。</li>
</ol>
<hr>
<blockquote>
<p>主要内容整理自 360 前端团队-奇舞团 公众号</p>
</blockquote>
]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
        <tag>DNS</tag>
        <tag>加密</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2和vue3的自定义指令</title>
    <url>/Vue/vue2%E5%92%8Cvue3%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>需要对普通 DOM 元素进行底层操作时，就可以用到自定义指令。</p>
<h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><h3 id="1）vue2-和-vue3-的主要区别——生命周期钩子不同："><a href="#1）vue2-和-vue3-的主要区别——生命周期钩子不同：" class="headerlink" title="1）vue2 和 vue3 的主要区别——生命周期钩子不同："></a>1）vue2 和 vue3 的主要区别——生命周期钩子不同：</h3><p>vue3：created， beforeMount， mounted，beforeUpdate， updated， beforeUnmount，unmounted</p>
<p>vue2：bind，inserted，update，componentUpdated，unbind</p>
<h3 id="2）其次是生命周期钩子函数的参数略有不同："><a href="#2）其次是生命周期钩子函数的参数略有不同：" class="headerlink" title="2）其次是生命周期钩子函数的参数略有不同："></a>2）其次是生命周期钩子函数的参数略有不同：</h3><h4 id="vue3-对应参数"><a href="#vue3-对应参数" class="headerlink" title="vue3 对应参数"></a>vue3 对应参数</h4><ol>
<li><strong>el</strong>：指令所绑定的元素，可以用来直接操作 DOM。</li>
<li><strong>binding</strong>： 一个对象，包含以下 property：<ol>
<li><strong>instance</strong>：使用指令的组件实例。 //</li>
<li><strong>value</strong>：传递给指令的值。例如，在 v-my-directive=”1 + 1” 中，该值为 2。</li>
<li><strong>oldValue</strong>：先前的值，仅在 beforeUpdate 和 updated 中可用。值是否已更改都可用。</li>
<li><strong>arg</strong>：参数传递给指令 (如果有)。例如在 v-my-directive:foo 中，arg 为 “foo”。</li>
<li><strong>modifiers</strong>：包含修饰符 (如果有) 的对象。例如在 v-my-directive.foo.bar 中，修饰符对象为 {foo: true，bar: true}。</li>
<li><strong>dir</strong>：一个对象，在注册指令时作为参数传递。例如，在以下指令中</li>
</ol>
</li>
<li><strong>vnode</strong>：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li>
<li><strong>oldVnode</strong>：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ol>
<h4 id="vue2-对应参数"><a href="#vue2-对应参数" class="headerlink" title="vue2 对应参数"></a>vue2 对应参数</h4><ol>
<li><strong>el</strong>：指令所绑定的元素，可以用来直接操作 DOM。</li>
<li><strong>binding</strong>：一个对象，包含以下 property：<ol>
<li><strong>name</strong>：指令名，不包括 v- 前缀。</li>
<li><strong>value</strong>：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li>
<li><strong>oldValue</strong>：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
<li><strong>expression</strong>：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li>
<li><strong>arg</strong>：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>
<li><strong>modifiers</strong>：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>
</ol>
</li>
<li><strong>vnode</strong>：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li>
<li><strong>oldVnode</strong>：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ol>
<h3 id="3）其次是简写时触发的生命周期钩子不同"><a href="#3）其次是简写时触发的生命周期钩子不同" class="headerlink" title="3）其次是简写时触发的生命周期钩子不同"></a>3）其次是简写时触发的生命周期钩子不同</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.directive(&#39;pin&#39;, (el, binding) &#x3D;&gt; &#123;</span><br><span class="line">  el.style.position &#x3D; &#39;fixed&#39;</span><br><span class="line">  const s &#x3D; binding.arg || &#39;top&#39;</span><br><span class="line">  el.style[s] &#x3D; binding.value + &#39;px&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如上写法，</p>
<p>在 vue3 中表示在 <strong>mounted</strong><code>和</code><strong>updated</strong> 触发回调函数的内容</p>
<p>在 vue2 中表示在 <strong>bind</strong><code>和</code><strong>update</strong> 触发回调函数的内容</p>
<h3 id="4）最后，vue3-多个根节点行为"><a href="#4）最后，vue3-多个根节点行为" class="headerlink" title="4）最后，vue3 多个根节点行为"></a>4）最后，vue3 多个根节点行为</h3><p>当在组件中使用时，<strong>自定义指令总是会被应用在组件的根节点上</strong>。当然前提条件是组件只有一个根节点。</p>
<p>但是 vue3 引入了多个根节点。</p>
<p>这时，<strong>当自定义指令被应用在一个多根节点的组件上时，指令会被忽略，并且会抛出一个警告。</strong></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="vue3-示例"><a href="#vue3-示例" class="headerlink" title="vue3 示例"></a>vue3 示例</h3><h4 id="全局注册："><a href="#全局注册：" class="headerlink" title="全局注册："></a>全局注册：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">app.directive(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素挂载到 DOM 中时……</span></span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="局部注册："><a href="#局部注册：" class="headerlink" title="局部注册："></a>局部注册：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><p><strong>created</strong>：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用。</p>
<p><strong>beforeMount</strong>：当指令第一次绑定到元素并且在挂载父组件之前调用。</p>
<p><strong>mounted</strong>：在绑定元素的父组件被挂载后调用。</p>
<p><strong>beforeUpdate</strong>：在更新包含组件的 VNode 之前调用。</p>
<p><strong>updated</strong>：在包含组件的 VNode 及其子组件的 VNode 更新后调用。</p>
<p><strong>beforeUnmount</strong>：在卸载绑定元素的父组件之前调用</p>
<p><strong>unmounted</strong>：当指令与元素解除绑定且父组件已卸载时，只调用一次。</p>
<h3 id="vue2-示例"><a href="#vue2-示例" class="headerlink" title="vue2 示例"></a>vue2 示例</h3><h4 id="全局注册：-1"><a href="#全局注册：-1" class="headerlink" title="全局注册："></a>全局注册：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="局部注册：-1"><a href="#局部注册：-1" class="headerlink" title="局部注册："></a>局部注册：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    	el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h4><p><strong>bind</strong>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p><strong>inserted</strong>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
<p><strong>update</strong>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
<p><strong>componentUpdated</strong>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>
<p><strong>unbind</strong>：只调用一次，指令与元素解绑时调用。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue3</tag>
        <tag>自定义指令</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3多个根节点上的Attribute继承</title>
    <url>/Vue/vue3%E5%A4%9A%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84Attribute%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><strong>vue3 可以给每个都绑定$attrs</strong></p>
<h2 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h2><p>vue2 由于只有一个根节点，因此不作为 prop 识别的属性(attribute)会直接绑定到根节点上，不需要另行设置。</p>
<p>vue3 中组件引入了多个根节点的情况，这时不被识别为 prop 的属性(attribute)，可以分别绑定到所有根节点上。</p>
<h2 id="vue3-方式"><a href="#vue3-方式" class="headerlink" title="vue3 方式"></a>vue3 方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child @submit&#x3D;&quot;onsubmit&quot; name&#x3D;&quot;123&quot; class&#x3D;&quot;hd&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line"></span><br><span class="line">app.component(&#39;child&#39;, &#123; template: &#96;</span><br><span class="line">&lt;header v-bind&#x3D;&quot;$attrs&quot;&gt; 头部 &lt;&#x2F;header&gt;</span><br><span class="line">&lt;div v-bind&#x3D;&quot;$attrs&quot;&gt; body &lt;&#x2F;div&gt;</span><br><span class="line">&lt;footer v-bind&#x3D;&quot;$attrs&quot;&gt; 底部 &lt;&#x2F;footer&gt;</span><br><span class="line">&#96;, &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/vue3%E7%A4%BA%E4%BE%8B1.png" alt="image"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue3</tag>
        <tag>attribute</tag>
        <tag>$attrs</tag>
      </tags>
  </entry>
  <entry>
    <title>vite资源引用报错</title>
    <url>/Vue/vite%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="vite-构建-vue3-项目，资源引用报错"><a href="#vite-构建-vue3-项目，资源引用报错" class="headerlink" title="vite 构建 vue3 项目，资源引用报错"></a>vite 构建 vue3 项目，资源引用报错</h2><p>使用 vite 创建 vue3 项目，开发环境一直没问题，打包时就报找不到资源路径的错误，翻阅文档方知，引用资源时，vite.config.js 中配置的路径别名并不好用。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法-1："><a href="#方法-1：" class="headerlink" title="方法 1："></a>方法 1：</h3><ol>
<li><p>将 <strong>/src/assets</strong> 目录的内容移动到 <strong>/public/assets</strong></p>
</li>
<li><p>将 templete 中引用资源改写为：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">  :src&#x3D;&quot;</span><br><span class="line">    &#39;.&#x2F;assets&#x2F;img&#x2F;cities&#x2F;&#39; +</span><br><span class="line">    build.type +</span><br><span class="line">    &#39;_&#39; +</span><br><span class="line">    build.faction +</span><br><span class="line">    &#39;_&#39; +</span><br><span class="line">    build.level +</span><br><span class="line">    &#39;.png&#39;</span><br><span class="line">  &quot;</span><br><span class="line">  class&#x3D;&quot;build-img&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将 css 中引用资源改写为：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(&quot;/<span class="selector-tag">assets</span>/<span class="selector-tag">img</span>/<span class="selector-tag">our_selector</span><span class="selector-class">.png</span>&quot;) <span class="selector-tag">no-repeat</span>;</span><br></pre></td></tr></table></figure>
<h3 id="方法-2："><a href="#方法-2：" class="headerlink" title="方法 2："></a>方法 2：</h3><ol>
<li><p>在 script 中使用 import imgUrl from ‘ /assets/img/our_selector.png ‘ ，获取资源路径</p>
</li>
<li><p>将 imgUrl 变量赋值给需要引用的地方</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    imgUrl</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题情况："><a href="#问题情况：" class="headerlink" title="问题情况："></a>问题情况：</h2><p>资源在 src 下的 assets 文件夹，在 template 和 style 中使用路径别名引入，开发时没毛病，build 后就找不到资源了。</p>
<p>在 vite 中设置路径别名如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line"></span><br><span class="line">*<span class="comment">// 键必须以斜线开始和结束*</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/@/&quot;</span>: path.resolve(__dirname, <span class="string">&quot;./src/&quot;</span>),</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>此时资源地址为 /src/assets/….. 项目中需要用到资源的地方如下，及 template 与 css 中引入资源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">  :src&#x3D;&quot;</span><br><span class="line">    &#39;&#x2F;@&#x2F;assets&#x2F;img&#x2F;cities&#x2F;&#39; +</span><br><span class="line">    build.type +</span><br><span class="line">    &#39;_&#39; +</span><br><span class="line">    build.faction +</span><br><span class="line">    &#39;_&#39; +</span><br><span class="line">    build.level +</span><br><span class="line">    &#39;.png&#39;</span><br><span class="line">  &quot;</span><br><span class="line">  class&#x3D;&quot;build-img&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">url</span>(&quot;/@/assets/img/our_selector.png&quot;) no-repeat;</span><br></pre></td></tr></table></figure>
<h3 id="build-时报错：（找不到-css-url-中的资源）"><a href="#build-时报错：（找不到-css-url-中的资源）" class="headerlink" title="build 时报错：（找不到 css url()中的资源）"></a>build 时报错：（找不到 css url()中的资源）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: ENOENT: no such file or directory, open &#x27;C:\Users\wwwangl\Desktop\land-grabber-web\@\assets\img\our_selector.png&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="build-后报错：（找不到-template-中-img-src-应用的资源）"><a href="#build-后报错：（找不到-template-中-img-src-应用的资源）" class="headerlink" title="build 后报错：（找不到 template 中 img src 应用的资源）"></a>build 后报错：（找不到 template 中 img src 应用的资源）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET http://10.64.94.40:5500/@/assets/img/cities/Town_green_1.png 404 (Not Found)</span><br></pre></td></tr></table></figure>
<h2 id="文档出处："><a href="#文档出处：" class="headerlink" title="文档出处："></a>文档出处：</h2><p><a href="https://vitejs.dev/guide/features.html#css-pre-processors">https://vitejs.dev/guide/features.html#css-pre-processors</a></p>
<h3 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h3><blockquote>
<h3 id="URL-Imports"><a href="#URL-Imports" class="headerlink" title="URL Imports"></a>URL Imports</h3><p>Importing a static asset will return the resolved public URL when it is served:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import imgUrl from &#39;.&#x2F;img.png&#39;</span><br><span class="line">document.getElementById(&#39;hero-img&#39;).src &#x3D; imgUrl</span><br></pre></td></tr></table></figure>

<p>The behavior is similar to webpack’s <code>file-loader</code>. The difference is that the import can be either using absolute<br>public paths (based on project root during dev) or relative paths.</p>
<ul>
<li><code>url()</code> references in CSS are handled the same way.</li>
<li>If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.</li>
<li>Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using<br>the <a href="https://vitejs.dev/config/#assetsinclude"><code>assetsInclude</code> option</a>.</li>
<li>Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed<br>by plugins for optimization.</li>
<li>Assets smaller in bytes than the <a href="https://vitejs.dev/config/#assetsinlinelimit"><code>assetsInlineLimit</code> option</a> will be<br>inlined as base64 data URLs.</li>
</ul>
<h3 id="The-public-Directory"><a href="#The-public-Directory" class="headerlink" title="#The public Directory"></a><a href="https://vitejs.dev/guide/features.html#the-public-directory">#</a>The <code>public</code> Directory</h3><p>If you have assets that are:</p>
<ul>
<li>Never referenced in source code (e.g. <code>robots.txt</code>)</li>
<li>Must retain the exact same file name (without hashing)</li>
<li>…or you simply don’t want to have to import an asset first just to get its URL</li>
</ul>
<p>Then you can place the asset in a special <code>public</code> directory under your project root. Assets in this directory will be<br>served at root path <code>/</code> during dev, and copied to the root of the dist directory as-is.</p>
<p>Note that:</p>
<ul>
<li>You should always reference <code>public</code> assets using root absolute path - for example, <code>public/icon.png</code> should be<br>referenced in source code as <code>/icon.png</code>.</li>
<li>Assets in <code>public</code> cannot be imported from JavaScript.</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue3</tag>
        <tag>vite</tag>
        <tag>@</tag>
        <tag>资源引用</tag>
      </tags>
  </entry>
  <entry>
    <title>chexcel</title>
    <url>/Project/chexcel/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>chexcel 基于 SheetJS 的 js-xlsx，官方 github: <a href="https://github.com/SheetJS/sheetjs">https://github.com/SheetJS/sheetjs</a>，通过 js-xlsx 读取用户上传的 Excel 文件，接受用户定义的校验规则，对文件内容逐一进行对比校验，并返回校验结果。</p>
<p>源码位置：</p>
<p>github：<a href="https://github.com/six-u/chexcel">https://github.com/six-u/chexcel</a></p>
<p>gitee：<a href="https://gitee.com/six-u/chexcel">https://gitee.com/six-u/chexcel</a></p>
<h1 id="chexcel-使用指南"><a href="#chexcel-使用指南" class="headerlink" title="chexcel 使用指南"></a>chexcel 使用指南</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx webpack --mode production  // 生产环境</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx webpack --mode development // 开发环境</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>点击查看 <a href="https://six-u.gitee.io/project/chexcel-demo/index.html">demo</a></p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>直接引入打包生成的 js 文件，实例挂载在 window 上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;chexcel.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chexcel.verify(file, option).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 校验结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table>
<thead>
<tr>
<th>key</th>
<th>description</th>
<th>default</th>
</tr>
</thead>
<tbody><tr>
<td>file</td>
<td>需要校验的 excel 文件</td>
<td>无</td>
</tr>
<tr>
<td>option</td>
<td>校验规则配置，详见下</td>
<td>无</td>
</tr>
</tbody></table>
<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>完整 option 配置示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Sheet1: &#123; <span class="comment">// sheet表名</span></span><br><span class="line">    <span class="comment">// column config</span></span><br><span class="line">    columnName: &#123;  <span class="comment">// 列名</span></span><br><span class="line">      required: <span class="literal">true</span>, <span class="comment">// 是否必传，Boolean， 默认为undefined</span></span><br><span class="line">      pattern: <span class="regexp">/^[A-Z]&#123;1,2&#125;[0-9]+$/</span>,  <span class="comment">// 自定校验正则，RegExp，默认为undefined</span></span><br><span class="line">      minLength: <span class="number">5</span>, <span class="comment">// 最小字符长度，Number，默认为undefined</span></span><br><span class="line">      maxLength: <span class="number">20</span>, <span class="comment">//最大字符长度，Number，默认为undefined</span></span><br><span class="line">      length: <span class="literal">undefined</span>, <span class="comment">// 字符长度，Number，默认为undefined</span></span><br><span class="line">      min: <span class="literal">undefined</span>, <span class="comment">// 最小值，Number，默认为undefined</span></span><br><span class="line">      max: <span class="literal">undefined</span>, <span class="comment">// 最大值，Number，默认为undefined</span></span><br><span class="line">      format: <span class="literal">undefined</span>, <span class="comment">// 使用默认正则，可通过chexcel.setFormat调用添加（暂未实现），String，默认为undefined</span></span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">cell, validate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/^[A-Z]&#123;1,2&#125;[0-9]&#123;3,7&#125;$/</span>.test(cell)) &#123;</span><br><span class="line">          validate.pattern = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="comment">// 自定义校验方法，若存在则不进行其他规则校验，Function，默认为undefined</span></span><br><span class="line">      include: <span class="literal">undefined</span>, <span class="comment">// 是否包含在给定的值中，需传入数组，Array，默认为undefined</span></span><br><span class="line">      norepeat: <span class="literal">true</span>, <span class="comment">// 列重复校验，Boolean，默认为undefined</span></span><br><span class="line">      tips: <span class="string">&quot;必填，接受5-20位字符，以1到2位大写字母开头后跟至少1位数字，且本列数据不可重复&quot;</span>,  <span class="comment">// 校验不通过时显示的提示信息，String，默认为undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...  // 其他列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... // 其他sheet表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h5><p>自定义校验函数，<strong>尚不支持异步校验。</strong></p>
<table>
<thead>
<tr>
<th>params</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>cell</td>
<td>String</td>
<td>当前单元格的值</td>
</tr>
<tr>
<td>validate</td>
<td>Object</td>
<td>校验结果</td>
</tr>
</tbody></table>
<p>校验结果返回，只需设置 validate 对应的属性即可，true 表示校验通过或不需校验，false 表示校验不通过，默认均为 true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">validate = &#123;</span><br><span class="line">  required: <span class="literal">true</span>,</span><br><span class="line">  include: <span class="literal">true</span>,</span><br><span class="line">  pattern: <span class="literal">true</span>,</span><br><span class="line">  format: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="literal">true</span>,</span><br><span class="line">  minLength: <span class="literal">true</span>,</span><br><span class="line">  maxLength: <span class="literal">true</span>,</span><br><span class="line">  min: <span class="literal">true</span>,</span><br><span class="line">  max: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>校验为异步校验，采用 promise 编写，需在 then 中接收校验结果。</p>
<p><strong>可能的情况：</strong></p>
<h4 id="1-没有数据"><a href="#1-没有数据" class="headerlink" title="1.没有数据"></a>1.没有数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: -<span class="number">1</span>,</span><br><span class="line">    data: <span class="string">&quot;no data&quot;</span>,</span><br><span class="line">    output: <span class="string">&quot;no data&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-配置-option-和文件表格列不匹配"><a href="#2-配置-option-和文件表格列不匹配" class="headerlink" title="2.配置 option 和文件表格列不匹配"></a>2.配置 option 和文件表格列不匹配</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: -<span class="number">2</span>,</span><br><span class="line">    data: <span class="string">&quot;Table column names do not match&quot;</span>,</span><br><span class="line">    output: <span class="string">&quot;Table column names do not match&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-校验通过"><a href="#3-校验通过" class="headerlink" title="3.校验通过"></a>3.校验通过</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    data: &#123;<span class="comment">/* ... */</span>&#125;,</span><br><span class="line">    output: <span class="string">&quot;All success&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-校验不通过"><a href="#4-校验不通过" class="headerlink" title="4.校验不通过"></a>4.校验不通过</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="number">1</span>,</span><br><span class="line">    data: &#123;<span class="comment">/* ... */</span>&#125;,</span><br><span class="line">    output: &#123;<span class="comment">/* ... */</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="data"><a href="#data" class="headerlink" title="data"></a>data</h5><p>返回校验结果原始数据，仅返回校验不通过的数据，示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	sheet表名:[</span><br><span class="line">        &#123;</span><br><span class="line">            column1:&#123;</span><br><span class="line">                <span class="comment">// line: 3,  // 校验不通过的行号（暂未添加）</span></span><br><span class="line">                format: <span class="literal">true</span>,</span><br><span class="line">                include: <span class="literal">true</span>,</span><br><span class="line">                length: <span class="literal">true</span>,</span><br><span class="line">                max: <span class="literal">true</span>,</span><br><span class="line">                maxLength: <span class="literal">true</span>,</span><br><span class="line">                min: <span class="literal">true</span>,</span><br><span class="line">                minLength: <span class="literal">true</span>,</span><br><span class="line">                norepeat: <span class="literal">true</span>,</span><br><span class="line">                pattern: <span class="literal">true</span>,</span><br><span class="line">                required: <span class="literal">false</span>, <span class="comment">// 表示必填验证未通过</span></span><br><span class="line">                tips: <span class="string">&quot;********&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// ... // 本行其他列</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ... // 其他行</span></span><br><span class="line">	],</span><br><span class="line">    <span class="comment">// ... // 其他sheet表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5><p>返回校验结果组装了提醒语句的数据，仅返回校验不通过的数据，示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	sheet表名:[</span><br><span class="line">		&#123;</span><br><span class="line">			line: <span class="number">3</span>, <span class="comment">// 校验不通过的行号</span></span><br><span class="line">			tips:[ <span class="comment">// 校验不通过的列及tips提示</span></span><br><span class="line">				&#123;</span><br><span class="line">					column: <span class="string">&quot;columnName&quot;</span></span><br><span class="line">                	tips: <span class="string">&quot;********&quot;</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="comment">// ... // 本行其他列</span></span><br><span class="line">			]</span><br><span class="line">		&#125;,</span><br><span class="line">        <span class="comment">// ... // 其他行</span></span><br><span class="line">	]，</span><br><span class="line">    <span class="comment">// ... // 其他sheet表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="chexcel-setTips-tips"><a href="#chexcel-setTips-tips" class="headerlink" title="chexcel.setTips(tips)"></a>chexcel.setTips(tips)</h4><p>自定义 default tips，当校验不通过时，用于提示用户。</p>
<p>chexcel 内置有默认提示，但比较简单，即 tips 默认值，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">baseTips = &#123;</span><br><span class="line">  required: <span class="string">&quot;必填&quot;</span>,</span><br><span class="line">  pattern: <span class="string">&quot;正则验证不通过&quot;</span>,</span><br><span class="line">  minLength: <span class="string">&quot;长度不够&quot;</span>,</span><br><span class="line">  maxLength: <span class="string">&quot;超出长度限制&quot;</span>,</span><br><span class="line">  length: <span class="string">&quot;长度不对&quot;</span>,</span><br><span class="line">  min: <span class="string">&quot;小于接受的最小值&quot;</span>,</span><br><span class="line">  max: <span class="string">&quot;超出接受的最大值&quot;</span>,</span><br><span class="line">  include: <span class="string">&quot;值没有包含在&quot;</span>,</span><br><span class="line">  format: <span class="string">&quot;format验证不通过&quot;</span>,</span><br><span class="line">  norepeat: <span class="string">&quot;重复数据&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>setTips 传入的 config 与默认对象采用 Object.assign(baseTips,tips)的形式合并。</p>
<p>优先级：chexcel.verify 传入的 tips &gt; chexcel.setTips 传入的 tips &gt; default tips</p>
<h4 id="chexcel-setFormat-format"><a href="#chexcel-setFormat-format" class="headerlink" title="chexcel.setFormat(format)"></a>chexcel.setFormat(format)</h4><p>用于设置默认正则，对应 chexcel.verify 传入的 option 中的 format</p>
<p>chexcel 内置基础 format，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">defaultFormat = &#123;</span><br><span class="line">  number: <span class="regexp">/^[0-9]+$/</span>,</span><br><span class="line">  email: <span class="regexp">/^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/</span>,</span><br><span class="line">  tel: <span class="regexp">/^1[3456789]\d&#123;9&#125;$/</span>,</span><br><span class="line">  url: <span class="regexp">/^[A-Za-z]+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9]+\.[A-Za-z0-9-_%&amp;\?\/=]+$/</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>setFormat 传入的 format 与默认对象采用 Object.assign(defaultFormat,format)的形式合并。</p>
<h5 id="使用-format"><a href="#使用-format" class="headerlink" title="使用 format"></a>使用 format</h5><p>在调用 chexcel.verify 时，设置需要的各列的 format 值为对应的正则的 key 即可，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">format: <span class="string">&quot;number&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>表示使用 正则：**/^[0-9]+$/** 去校验该列的值</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>js-xlsx</tag>
        <tag>Excel</tag>
        <tag>校验</tag>
        <tag>chexcel</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM边角料</title>
    <url>/JS%E8%AF%AD%E6%B3%95/DOM%E8%BE%B9%E8%A7%92%E6%96%99/</url>
    <content><![CDATA[<h2 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h2><p>classList 属性返回 DOM 元素的类名组成的类数组，相当于原生实现了 jQuery 对类名的一些操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">DOMTokenList(<span class="number">4</span>) [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;tips&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="attr">value</span>: <span class="string">&quot;name tips type number&quot;</span>]</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;tips&quot;</span></span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;tim&quot;</span></span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">    value: <span class="string">&quot;tips number tim&quot;</span></span><br><span class="line">    __proto__: DOMTokenList</span><br></pre></td></tr></table></figure>
<p>classList 上的方法：</p>
<h3 id="add-class1-class2-…"><a href="#add-class1-class2-…" class="headerlink" title="add(class1, class2, …)"></a>add(<em>class1, class2, …</em>)</h3><p>作用：在元素中添加一个或多个类名，如果指定的类名已存在，则不会添加</p>
<h3 id="contains-class"><a href="#contains-class" class="headerlink" title="contains(class)"></a>contains(<em>class</em>)</h3><p>作用：返回布尔值，判断指定的类名是否存在，返回 true、false</p>
<h3 id="item-index"><a href="#item-index" class="headerlink" title="item(index)"></a>item(<em>index</em>)</h3><p>作用： 返回元素中索引值对应的类名。索引值从 0 开始，如果索引值在区间范围外则返回 <em>null</em></p>
<h3 id="remove-class1-class2-…"><a href="#remove-class1-class2-…" class="headerlink" title="remove(class1, class2, …)"></a>remove(<em>class1, class2, …</em>)</h3><p>作用：移除元素中一个或多个类名。 移除不存在的类名，不会报错。</p>
<h3 id="toggle-class-true-false"><a href="#toggle-class-true-false" class="headerlink" title="toggle(class, true|false)"></a>toggle(<em>class,</em> true|false)</h3><p>作用：在元素中切换类名。</p>
<p> 第一个参数为要在元素中移除的类名，并返回 false。如果该类名不存在则会在元素中添加类名，并返回 true。</p>
<p> 第二个是可选参数，用于设置元素是否强制添加或移除类，不管该类名是否存在</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#0f4</span>;</span></span><br><span class="line">    font-size: 3em;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.name</span> &#123;</span></span><br><span class="line">    color: brown;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;div name&quot;</span>&gt;</span>classList测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;d1&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(div.classList); <span class="comment">// div name</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// add</span></span></span><br><span class="line"><span class="javascript">  div.classList.add(<span class="string">&quot;tips&quot;</span>, <span class="string">&quot;moon&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(div.classList); <span class="comment">// div name tips moon</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// contains</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(div.classList.contains(<span class="string">&quot;type&quot;</span>)); <span class="comment">// false</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// remove</span></span></span><br><span class="line"><span class="javascript">  div.classList.remove(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;tips&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(div.classList); <span class="comment">// div name moon</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// toggle</span></span></span><br><span class="line"><span class="javascript">  div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.classList.toggle(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false/true交替</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="activeElement"><a href="#activeElement" class="headerlink" title="activeElement"></a>activeElement</h2><p>作用：返回文档中当前获得焦点的元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inputName&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inputAge&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sbm&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;sbmClick()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/demo/src/assets/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;img&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;imgClick()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;divClick()&quot;</span>&gt;</span>activeElement<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement.id); <span class="comment">//inputName</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> inputAge = <span class="built_in">document</span>.getElementById(<span class="string">&quot;inputAge&quot;</span>);</span></span><br><span class="line">    inputAge.focus();</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement.id); <span class="comment">//inputAge</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">sbmClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement.id); <span class="comment">// sbm</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">imgClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement.tagName); <span class="comment">// BODY</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">divClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement.tagName); <span class="comment">// BODY</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h2><p>HTMLElement.dataset 属性允许无论是在读取模式和写入模式下访问在 HTML 或 DOM 中的元素上设置的所有自定义数据属性(*data-**)集。就是可以用来访问元素上的自定义数据属性。不过访问的时候，如果元素上是短横线式的命名方式，在 js 中要转变为小驼峰的形式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;1234567890&quot;</span> <span class="attr">data-user</span>=<span class="string">&quot;johndoe&quot;</span> <span class="attr">data-date-of-birth</span>&gt;</span></span><br><span class="line">  John Doe</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#user&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// el.id == &#x27;user&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// el.dataset.id === &#x27;1234567890&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// el.dataset.user === &#x27;johndoe&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// el.dataset.dateOfBirth === &#x27;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  el.dataset.dateOfBirth = <span class="string">&quot;1960-10-03&quot;</span>; <span class="comment">// set the DOB.</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// &#x27;someDataAttr&#x27; in el.dataset === false</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  el.dataset.someDataAttr = <span class="string">&quot;mydata&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// &#x27;someDataAttr&#x27; in el.dataset === true</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h2><p>Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。</p>
<p>参数：</p>
<h3 id="scrollIntoView-Boolean"><a href="#scrollIntoView-Boolean" class="headerlink" title="scrollIntoView(Boolean)"></a>scrollIntoView(Boolean)</h3><ol>
<li><p>true: 表示滚动后元素的顶端将和其所在滚动区的可视区域的顶端对齐，不传参数等同于此</p>
</li>
<li><p>false: 表示滚动后元素的顶端将和其所在滚动区的可视区域的底端对齐</p>
</li>
</ol>
<h3 id="scrollIntoView-Object"><a href="#scrollIntoView-Object" class="headerlink" title="scrollIntoView(Object)"></a>scrollIntoView(Object)</h3><p> {</p>
<p> <strong>behavior</strong>：定义动画过渡效果， <code>&quot;auto&quot;</code>或 <code>&quot;smooth&quot;</code> 之一。默认为 auto。亲测 chrome 似乎没有动画效果。</p>
<p> <strong>block</strong>：定义垂直方向的对齐，即垂直滚动是有效， <code>&quot;start&quot;</code>, <code>&quot;center&quot;</code>, <code>&quot;end&quot;</code>, 或 <code>&quot;nearest&quot;</code>之一。默认为 <code>&quot;start&quot;</code>。</p>
<p> <strong>inline</strong>：定义水平方向的对齐，即水平滚动时有效， <code>&quot;start&quot;</code>, <code>&quot;center&quot;</code>, <code>&quot;end&quot;</code>, 或 <code>&quot;nearest&quot;</code>之一。默认为 <code>&quot;nearest&quot;</code>。</p>
<p> }</p>
<p><strong>注意</strong>：</p>
<ol>
<li><p>“start” 表示顶或者左对齐</p>
</li>
<li><p>“center”表示居中</p>
</li>
<li><p>“end”表示底或右对齐</p>
</li>
<li><p>“nearest”表示滚动到完整出现在可视区域中就停止了，比如元素开始在可视区域下方，则滚动到与可视区域的底端对齐时就停止，下同。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>classList</tag>
        <tag>dataset</tag>
        <tag>scrollIntoView</tag>
      </tags>
  </entry>
  <entry>
    <title>window和global</title>
    <url>/JS%E8%AF%AD%E6%B3%95/window%E5%92%8Cglobal/</url>
    <content><![CDATA[<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>在 ECMAScript 中，有一个全局的兜底对象，也即是 GO。但浏览器实际实现 GO 的方式都是，将 GO 作为 window 的子集，也即将 GO 是现在 window 上。<br>但 window 不止于 global，还会在浏览器上实现相应的 BOM 方法。</p>
<p><strong>在全局作用域声明的变量、函数都会变成 window 的属性和方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">window</span>.c = <span class="string">&quot;#f40&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// &quot;#f40&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.getName()); <span class="comment">// &quot;#f40&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是，</p>
<p><strong>全局变量不能通过 delete 操作符删除，而直接在 window 对象上定义的属性则可以删除。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>; <span class="comment">// (*)</span></span><br><span class="line"><span class="built_in">window</span>.c = <span class="string">&quot;23&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.a); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>若是上面代码中(*)位置写作如下样子，会是什么情况？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">12</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">12</span>; <span class="comment">// (*)</span></span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa = <span class="number">1212</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// 1212</span></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 1212</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.aa); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> aa); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// Uncaught ReferenceError: aa is not defined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1212</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 1212</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.aa); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> aa); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 1212</span></span><br></pre></td></tr></table></figure>
<p>可见，执行 aa=1212 相当于执行 window.aa = 1212，而执行 let aa = 1212 时，aa 并没有挂载到 window 上。</p>
<p>这是由于，ES6 中引入了块级作用域的概念，使用<code>let</code>，声明的变量仅在块级作用域内有效。</p>
<h3 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<blockquote>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
</blockquote>
<p>ES5 顶层对象的属性赋值与全局变量的赋值，是同一件事：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>ES6 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
<p>这就解释为什么 var a=12，a=12,let a=12 之间会有那些不同：</p>
<ol>
<li>var 声明的变量为顶层对象的属性，不能通过 delete 操作符删除</li>
<li>不通过关键声明直接，直接赋值使用的变量等价于设置全局对象 window 的属性，可以通过 delete 操作符删除</li>
<li>而使用 let 声明的变量，即使在全局作用域声明，也不会称为顶层对象和全局对象 window 的属性，但他也不能通过 delete 操作符删除</li>
</ol>
<p>具体区别可参看，<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰 ECMAScript 6 入门 =&gt; let 和 const 命令</a></p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>window</tag>
        <tag>global</tag>
        <tag>全局对象</tag>
        <tag>let</tag>
        <tag>var</tag>
        <tag>顶层对象</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>html的meta标签</title>
    <url>/HTML%E5%92%8CCSS/html%E7%9A%84meta%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="设置示例"><a href="#设置示例" class="headerlink" title="设置示例"></a>设置示例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基础 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义文档关键词，用于SEO --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, XML, XHTML, JavaScript&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义web页面描述，用于SEO --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Free Web tutorials on HTML and CSS&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义页面作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Six U&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每30秒刷新页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 针对手持设备优化 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放 --&gt;</span></span><br><span class="line">&lt;meta</span><br><span class="line">  name=&quot;viewport&quot;</span><br><span class="line">  content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;MobileOptimized&quot;</span> <span class="attr">content</span>=<span class="string">&quot;320&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;screen-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;full-screen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;browsermode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;application&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-page-mode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="关于-viewport-的更多知识"><a href="#关于-viewport-的更多知识" class="headerlink" title="关于 viewport 的更多知识"></a>关于 viewport 的更多知识</h2><p><a href="https://www.runoob.com/w3cnote/viewport-deep-understanding.html">viewport 深入理解</a></p>
<p><a href="https://www.cnblogs.com/2050/p/3877280.html">viewport 深入理解</a></p>
]]></content>
      <categories>
        <category>HTML和CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>meta</tag>
        <tag>viewport</tag>
      </tags>
  </entry>
  <entry>
    <title>JS深度优先广度优先</title>
    <url>/algorithm/JS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</url>
    <content><![CDATA[<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>原理：自上而下的遍历搜索，常用递归实现</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/deepFirst.jpg"></p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepthFirst = <span class="function"><span class="params">tree</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  tree.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    result.push(item.key);</span><br><span class="line">    <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">      result.push(...deepthFirst(item.children));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deepthFirst(data).join(<span class="string">&quot;&quot;</span>)); <span class="comment">// Lrennidn gmd. aetkhees  afmreo nbta l</span></span><br></pre></td></tr></table></figure>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>原理：逐层遍历搜索，可用队列实现</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/breadFirst.jpg"></p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> breadthFirst = <span class="function"><span class="params">tree</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> temp = [...tree]; <span class="comment">// 队列</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (temp.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = temp.shift();</span><br><span class="line">    result.push(item.key);</span><br><span class="line">    <span class="keyword">if</span> (item.children &amp;&amp; item.children.length) &#123;</span><br><span class="line">      temp.push(...item.children);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(breadthFirst(data).join(<span class="string">&quot;&quot;</span>)); <span class="comment">// Learning the front end makes me bald</span></span><br></pre></td></tr></table></figure>
<h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">&quot;L&quot;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;r&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;e&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;n&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;n&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;i&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;d&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;n&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot; &quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        key: <span class="string">&quot;g&quot;</span>,</span><br><span class="line">        children: [&#123; <span class="attr">key</span>: <span class="string">&quot;m&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;d&quot;</span> &#125;, &#123; <span class="attr">key</span>: <span class="string">&quot;.&quot;</span> &#125;] &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        key: <span class="string">&quot; &quot;</span>,</span><br><span class="line">        children: [&#123; <span class="attr">key</span>: <span class="string">&quot;a&quot;</span> &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">&quot;e&quot;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;t&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;k&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;h&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;e&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;e&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;s&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot; &quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot; &quot;</span> &#125;] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;f&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;m&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;r&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;e&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;o&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot; &quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;n&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot;t&quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;a&quot;</span> &#125;] &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&quot; &quot;</span>, <span class="attr">children</span>: [&#123; <span class="attr">key</span>: <span class="string">&quot;l&quot;</span> &#125;] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS算法</category>
        <category>遍历算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度优先</tag>
        <tag>广度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>空值合并操作符(??)和可选链式操作符(?.)</title>
    <url>/JS%E8%AF%AD%E6%B3%95/%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符(??)"></a>空值合并操作符(??)</h2><p>空值合并操作符(??)是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nullValue = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> emptyText = <span class="string">&quot;&quot;</span>; <span class="comment">// 空字符串，是一个假值，Boolean(&quot;&quot;) === false</span></span><br><span class="line"><span class="keyword">const</span> someNumber = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> valA = nullValue ?? <span class="string">&quot;valA 的默认值&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> valB = emptyText ?? <span class="string">&quot;valB 的默认值&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> valC = someNumber ?? <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(valA); <span class="comment">// &quot;valA 的默认值&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(valB); <span class="comment">// &quot;&quot;（空字符串虽然是假值，但不是 null 或者 undefined）</span></span><br><span class="line"><span class="built_in">console</span>.log(valC); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h3 id="和逻辑操作符-的区别"><a href="#和逻辑操作符-的区别" class="headerlink" title="和逻辑操作符(||)的区别"></a>和逻辑操作符(||)的区别</h3><p>(||)是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（<code>0</code>， <code>&#39;&#39;</code>， <code>NaN</code>， <code>null</code>， <code>undefined</code>）都不会被返回。这导致如果你使用<code>0</code>，<code>&#39;&#39;</code>或<code>NaN</code>作为有效值，就会出现不可预料的后果。</p>
<p>比如实际使用中，多条件搜索时，希望没有值的搜索条件不被发送。这是就需要对搜索条件判空。若是使用(||)，当搜索条件中存在状态为 0 的情况时，就很容易出现状态 0 不被上传的情况。</p>
<p>使用(??)可以解决这个问题，(??)是只有当左侧的操作数为 null 或者 undefined 时，才返回其右侧操作数，否则返回左侧操作数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = &#123;</span><br><span class="line">    current: <span class="number">1</span>,</span><br><span class="line">    pageSize: <span class="number">10</span>,</span><br><span class="line">    status: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">&#x27;search&#x27;</span>，</span><br><span class="line">    sex: <span class="literal">null</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(filter).forEach(<span class="function"><span class="params">v</span>=&gt;</span> v || <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// ajax send filter</span></span><br><span class="line"><span class="comment">//...  status,sex 不会被发送</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(filter).forEach(<span class="function"><span class="params">v</span>=&gt;</span> v ?? <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// ajax send filter</span></span><br><span class="line"><span class="comment">//...  只有 sex 不会被发送</span></span><br></pre></td></tr></table></figure>
<h3 id="不能与-AND-amp-amp-和-OR-共用"><a href="#不能与-AND-amp-amp-和-OR-共用" class="headerlink" title="不能与 AND(&amp;&amp;)和 OR(||)共用"></a>不能与 AND(&amp;&amp;)和 OR(||)共用</h3><p>(??)和(&amp;&amp;)、(||)直接一起使用是不行的，但是用或括号区分之后，能够使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 抛出 SyntaxError</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 抛出 SyntaxError</span></span><br><span class="line">(<span class="literal">null</span> || <span class="literal">undefined</span> ) ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 返回 &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/kzhbjrx.png"></p>
<h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符(?.)"></a>可选链操作符(?.)</h2><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>(?.)允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。</p>
<p>(?.)操作符的功能类似于(.)链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。</p>
<p>(?.)与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。若给定的函数名存在但不是函数，则一个 TypeError 异常 (x.y is not a function)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Optional&#x27;</span>,</span><br><span class="line">  level: [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>]</span><br><span class="line">  hat: &#123;</span><br><span class="line">    color: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">    size: <span class="string">&#x27;big&#x27;</span>,</span><br><span class="line">    baseInfo: &#123;</span><br><span class="line">      manufacturer: <span class="string">&#x27;GIaoo&#x27;</span>,</span><br><span class="line">      origin: <span class="string">&#x27;China&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj?.hat?.color) <span class="comment">// black</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.sex?.color) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.getName?.()) <span class="comment">// Optional</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.hat?.()) <span class="comment">// TypeError: obj?.hat is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选链操作符(?.)不能用于赋值</span></span><br><span class="line">object?.property = <span class="number">1</span>; <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选链操作符(?.)也可用于访问数组元素</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.level?.[<span class="number">3</span>]) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/kxlsjrx.png"></p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>可选链</tag>
        <tag>空值合并</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JS 的严格模式&#39;use strict&#39;</title>
    <url>/JS%E8%AF%AD%E6%B3%95/%E5%85%B3%E4%BA%8Eusestrict/</url>
    <content><![CDATA[<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li>在整个脚本顶部使用”use strict”，表示为整个脚本开启严格模式</li>
<li>在函数内顶部使用”use strict”，表示为当前函数开始严格模式</li>
</ol>
<h2 id="使用后的影响"><a href="#使用后的影响" class="headerlink" title="使用后的影响"></a>使用后的影响</h2><ol>
<li>严格模式通过<strong>抛出错误</strong>（直接报错，中止代码执行）来消除了一些原有<strong>静默错误</strong>（不报错，做默认处理或者使操作不生效），见示例代码。</li>
<li>严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下<strong>运行得更快</strong>（比如禁止<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with">with</a>的使用？）。</li>
<li>严格模式<strong>禁用了</strong>在 ECMAScript 的未来版本中可能会定义的一些语法，比如增加了以下保留字：implements, interface, let, package, private, protected, public, static 和 yield，其中部分已从 ES6 开始正式使用。</li>
</ol>
<p><em>注：严格模式代码和非严格模式代码可以共存，因此项目脚本可以渐进式地采用严格模式。</em></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义变量不使用var、let、const，报错。非严格模式不报错，且自动成为全局变量的属性</span></span><br><span class="line">a = <span class="number">17</span>; <span class="comment">// a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给只读属性写值，报错。非严格模式不报错，不生效。</span></span><br><span class="line"><span class="literal">NaN</span> = <span class="number">5</span>; <span class="comment">// Cannot assign to read only property &#x27;NaN&#x27; of object &#x27;#&lt;Object&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除不可删除属性，报错。非严格模式不报错，不生效。</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// Cannot delete property &#x27;prototype&#x27; of function Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.函数形参名不能相同，报错。非严格模式不报错，直接使用最后出现的一个，并且之前的相同的形参可通过arguments访问</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, a, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + a + c;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 非严格：7；严格：报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.使用只用0表示的八进制语法，报错。非严格模式可使用。ES6严格模式可使用&quot;0o&quot;开头表示八进制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0644</span> === <span class="number">420</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\045&quot;</span> === <span class="string">&quot;%&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">015</span>; <span class="comment">// Octal literals are not allowed in strict mode</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0o10</span>; <span class="comment">// ES6: 八进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.给原始值设置属性，报错TypeError。非严格模式不报错，不生效。</span></span><br><span class="line"><span class="literal">false</span>.true = <span class="string">&quot;&quot;</span>; <span class="comment">// TypeError：... ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.禁止使用with语句,报错。非严格模式不报错,正常执行 （任何时候都不建议使用with）</span></span><br><span class="line"><span class="keyword">let</span> ao = &#123;</span><br><span class="line">  name: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  meo: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>],</span><br><span class="line">  rship: &#123;</span><br><span class="line">    fa: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">    ma: <span class="string">&quot;Function&quot;</span>,</span><br><span class="line">    bro: <span class="string">&quot;Constructor&quot;</span>,</span><br><span class="line">    son: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">    par: <span class="string">&quot;proto&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (ao) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(meo[<span class="number">3</span>], rship.ma); <span class="comment">// Strict mode code may not include a with statement  // 10 Function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.严格模式下 eval 的情况请直接查看参考链接 （任何时候都不建议使用eval）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.严格模式禁止删除声明变量。delete name 在严格模式下会引起语法错误</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10.严格模式下 eval 和 arguments 相当于关键字，不能通过程序语法被绑定(be bound)或赋值</span></span><br><span class="line"><span class="built_in">eval</span> = <span class="number">17</span>; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="built_in">arguments</span>++; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line">++<span class="built_in">eval</span>; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="keyword">set</span> <span class="title">p</span>(<span class="params"><span class="built_in">arguments</span></span>) &#123;&#125; &#125;; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span>; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123;&#125; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"><span class="built_in">eval</span></span>) </span>&#123;&#125; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;arguments&quot;</span>, <span class="string">&quot;&#x27;use strict&#x27;; return 17;&quot;</span>); <span class="comment">// SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 11.严格模式下，参数的值不会随 arguments 对象的值的改变而变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 严格模式 3 3 // 非严格模式 3 3</span></span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 严格模式 0 3 // 非严格模式 0 0</span></span><br><span class="line">&#125;</span><br><span class="line">sumFn(<span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12.严格模式不支持 arguments.callee ，原理同10，不能被绑定</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them  //类型错误：在严格模式函数或调用它们的参数对象上，可能无法访问“ caller”，“ callee”和“ arguments”属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 13.严格模式下使用call, apply或者bind方法来指定一个确定的this时，如传入的不是对象，则不会自动转化或包装，详见关联文章：JS中的call和apply</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">this</span>.a);</span><br><span class="line">  <span class="keyword">return</span> x + y + z + <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(show.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a></p>
<h2 id="关联文章"><a href="#关联文章" class="headerlink" title="关联文章"></a>关联文章</h2><p><a href="https://six-u.gitee.io/JS%E5%9F%BA%E7%A1%80/JS%E4%B8%AD%E7%9A%84call%E5%92%8Capply/">JS 中的 call 和 apply</a></p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>严格模式</tag>
        <tag>use strict</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的call和apply</title>
    <url>/JS%E8%AF%AD%E6%B3%95/JS%E4%B8%AD%E7%9A%84call%E5%92%8Capply/</url>
    <content><![CDATA[<p>call 和 apply 都是位于 Function 的原型上，继承自 Function 对象的 js 方法都可以调用。</p>
<h2 id="Function-prototype-call-target-arg1-arg2-…"><a href="#Function-prototype-call-target-arg1-arg2-…" class="headerlink" title="Function.prototype.call(target, arg1, arg2, …)"></a>Function.prototype.call(target, arg1, arg2, …)</h2><p>作用：改变函数运行时，函数内部的 this 指向。（指定为 target）</p>
<p>参数：</p>
<ol>
<li><p>target：可选。在 <em><code>function</code></em> 函数运行时使用的 <code>this</code> 值。</p>
<p> <em>注：如果这个函数处于非严格模式下，target 为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，为原始值会被包装为包装类。</em></p>
</li>
<li><p> arg1, arg2, …：可选。用于传入原函数运行需要的参数</p>
</li>
</ol>
<p>返回值：与原函数的返回值相同</p>
<h2 id="Function-prototype-apply-target-argsArray"><a href="#Function-prototype-apply-target-argsArray" class="headerlink" title="Function.prototype.apply(target, [argsArray])"></a>Function.prototype.apply(target, [argsArray])</h2><p>作用：改变函数运行时，函数内部的 this 指向。（指定为 target）</p>
<p>参数：</p>
<ol>
<li>target：同 call。</li>
<li>[argsArray]：可选。用于传入原函数运行需要的参数数组或者类数组对象</li>
</ol>
<p>返回值：同 call。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>call,apply<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// &quot;use strict&quot;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> a = <span class="number">3</span>; <span class="comment">// 或 a = 3 , 此处使用let或const时，变量a不会成为window的属性</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x, y, z</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">this</span>.a);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> x + y + z + <span class="built_in">this</span>.a;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> ao = &#123;</span></span><br><span class="line">        a: 33,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// window, 3  // 6</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(ao, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)); <span class="comment">// ao, 33  // 39</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(ao, [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])); <span class="comment">// ao, 33  // 48</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 非严格模式</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">/* 当target传入null或undefined时，null或undefined会被替换为window*/</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// window, 3  // 6</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// window, 3  // 6</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// window, 3  // 6</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// window, 3  // 6</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">/* 当target传入原始值时，原始值会被包装为包装类 */</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="number">555</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Number &#123;555&#125; undefined  // NaN</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="number">555</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Number &#123;555&#125; undefined  // NaN</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="string">&quot;sss&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// String &#123;&quot;sss&quot;&#125; undefined  // NaN</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="string">&quot;sss&quot;</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// String &#123;&quot;sss&quot;&#125; undefined  // NaN</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="literal">true</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Boolean &#123;true&#125; undefined  // NaN</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="literal">true</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Boolean &#123;true&#125; undefined  // NaN</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 严格模式 &quot;use strict&quot;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="number">555</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="number">555</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="string">&quot;sss&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="string">&quot;sss&quot;</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.call(<span class="literal">true</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(show.apply(<span class="literal">true</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])); <span class="comment">// Cannot read property &#x27;a&#x27; of undefined</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>注：测试代码为浏览器环境，如为 node 环境，则没有 window，而是 global</em></p>
<h2 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h2><ol>
<li>作用相同，都是改变函数执行时的 this 指向</li>
<li>返回结果相同，都是返回原函数对应的结果</li>
<li>传参方式不同，call 为(target, arg1, arg2, …)，apply 为(target, [argsArray])</li>
</ol>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>树形基础</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%BD%A2%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="树结构-树形"><a href="#树结构-树形" class="headerlink" title="树结构 树形"></a>树结构 树形</h2><p>树存储结构适合存储具有“一对多”关系的数据。一种非线性结构。树是递归结构，在树的定义中又用到了树的概念。<br>树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null 或 empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/tree.jpeg"></p>
<h3 id="基本术语："><a href="#基本术语：" class="headerlink" title="基本术语："></a>基本术语：</h3><ol>
<li>树结点：包含一个数据元素及若干指向子树的分支；</li>
<li>孩子结点：结点的子树的根称为该结点的孩子；</li>
<li>双亲结点：B 结点是 A 结点的孩子，则 A 结点是 B 结点的双亲；</li>
<li>兄弟结点：同一双亲的孩子结点；</li>
<li>堂兄结点：同一层上结点；</li>
<li>结点层次：根结点的层定义为 1；根的孩子为第二层结点，依此类推；</li>
<li>树的高（深）度：树中最大的结点层</li>
<li>结点的度：结点子树的个数</li>
<li>树的度： 树中最大的结点度。</li>
<li>叶子结点：也叫终端结点，是度为 0 的结点；</li>
<li>分枝结点：度不为 0 的结点（非终端结点）；</li>
<li>森林：互不相交的树集合；</li>
<li>有序树：子树有序的树，如：家族树；</li>
<li>无序树：不考虑子树的顺序；<br>实例：普通树、二叉树（Binary tree）、堆（heap）、B-树（B tree）</li>
</ol>
<p>树是一种分层数据的抽象模型。它是一种非顺序数据结构，它对于存储需要快速查找的数据非常有用。<br>特点：</p>
<ol>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ol>
<h3 id="普通树"><a href="#普通树" class="headerlink" title="普通树"></a>普通树</h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ol>
<li>结点：树中的数据元素都称之为结点</li>
<li>根：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根</li>
<li>父亲：结点的上层结点，如图中，结点 B 的父亲是 E、结点 C 的父亲是 H</li>
<li>兄弟：具有相同父亲的结点称为兄弟，图中 E、F、G 互为兄弟</li>
<li>结点的度：结点所拥有的子树的个数称之为结点的度，如结点 B 的度为 3</li>
<li>树叶：度为 0 的结点，也叫作终端结点，图中 E、F、G、H、I、J 都是树叶</li>
<li>分支结点：度不为 0 的结点，也叫作非终端结点或内部结点，图中 A、B、C、D 都是分支结点</li>
<li>结点的层次：从根节点到树中某结点所经路径上的分支树称为该结点的层次，根节点的层次规定为 1，其余结点的层次等于其父亲结点的层次+1</li>
<li>树的深度：树中结点的最大层次数，图中树的深度为 3</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树（binary tree）是指树中节点的度不大于 2 的有序树。<br>二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。———— 二叉树分左右</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/binarytree.jpg"></p>
<ol>
<li>空二叉树——如图（a）；</li>
<li>只有一个根结点的二叉树——如图（b）；</li>
<li>只有左子树——如图（c）；</li>
<li>只有右子树——如图（d）；</li>
<li>完全二叉树——如图（e）。</li>
</ol>
<h4 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h4><p>性质 1：二叉树的第 i 层上至多有 2i-1（i≥1）个节点。<br>性质 2：深度为 h 的二叉树中至多含有 2h-1 个节点 。<br>性质 3：若在任意一棵二叉树中，有 n0 个叶子节点，有 n2 个度为 2 的节点，则必有 n0=n2+1 。<br>性质 4：具有 n 个节点的完全二叉树深为 log2x+1（其中 x 表示不大于 n 的最大整数） 。<br>性质 5：若对一棵有 n 个节点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为 i（i≥1）的节点：<br>当 i=1 时，该节点为根，它无双亲节点 。<br>当 i&gt;1 时，该节点的双亲节点的编号为 i/2 。<br>若 2i≤n，则有编号为 2 的左叶子，否则没有左叶子。<br>若 2+1≤n，则有编号为 2i+1 的右叶子，否则没有右叶子 。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>树形</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>JS快速排序</title>
    <url>/algorithm/JS%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，直到整个序列有序。</p>
<h2 id="JS-实现代码："><a href="#JS-实现代码：" class="headerlink" title="JS 实现代码："></a>JS 实现代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = [<span class="number">14</span>, <span class="number">64</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">29</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sort = <span class="function">(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">      <span class="comment">//如果左边的索引大于等于右边的索引说明整理完毕</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = left;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line">    <span class="keyword">const</span> baseVal = arr[j]; <span class="comment">// 取无序数组最后一个数为基准值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="comment">//把所有比基准值小的数放在左边大的数放在右边</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= baseVal) &#123;</span><br><span class="line">        <span class="comment">//找到一个比基准值大的数交换</span></span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = arr[i]; <span class="comment">// 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（i 等于 j）</span></span><br><span class="line">      <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt;= baseVal) &#123;</span><br><span class="line">        <span class="comment">//找到一个比基准值小的数交换</span></span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[i] = arr[j]; <span class="comment">// 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 j）</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = baseVal; <span class="comment">// 将基准值放至中央位置完成一次循环（这时候 j 等于 i ）</span></span><br><span class="line">    sort(arr, left, j - <span class="number">1</span>); <span class="comment">// 将左边的无序数组重复上面的操作</span></span><br><span class="line">    sort(arr, j + <span class="number">1</span>, right); <span class="comment">// 将右边的无序数组重复上面的操作</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// const newArr = array.concat(); // 为了保证这个函数是纯函数拷贝一次数组</span></span><br><span class="line">  sort(array);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(age)); <span class="comment">// [5, 7, 13, 14, 24, 29, 34, 45, 51, 64]</span></span><br></pre></td></tr></table></figure>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>时间复杂度：O(nlog2n)</p>
<p>空间复杂度：O(nlog2n)</p>
<p>稳定性：不稳定，当查找比基准值大或者小或者大于等于、小于等于的时候，与基准值相等的值仍然会被调换位置。</p>
]]></content>
      <categories>
        <category>JS算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>快速排序</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表和链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="顺序表和链表"><a href="#顺序表和链表" class="headerlink" title="顺序表和链表"></a>顺序表和链表</h2><p>特点：各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素）</p>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/4.jpg"></p>
<p>特点：使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的</p>
<p>实例：数组、队列、栈</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/2-1Q1260R610450.gif"></p>
<h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><p>特点：使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL）。这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表。</p>
<p>实例：链表</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/1-1Q11QH334H1.gif"></p>
<h3 id="常见线性表"><a href="#常见线性表" class="headerlink" title="常见线性表"></a>常见线性表</h3><h4 id="串（String）"><a href="#串（String）" class="headerlink" title="串（String）"></a>串（String）</h4><p>串是由零个或多个字符组成的有序序列，一般记为</p>
<p><strong>S=”a1a2…an”</strong> <strong>(n&gt;=0)</strong></p>
<p>其中，s 是串的名，用双引号括起来的字符序列是串的值；ai (1≤i≤n)可以是字母、数字或其他字符；串中字符的数目 n 成为串的<strong>长度</strong>。零个字符的串称为<strong>空串</strong>(null string),它的长度为 0。</p>
<h4 id="一维数组（Array）"><a href="#一维数组（Array）" class="headerlink" title="一维数组（Array）"></a>一维数组（Array）</h4><p>数组是一个存储元素的线性集合(collection),元素可以通过索引来任意存取,索引通常是数字,用来计算元素之间存储位置的偏移量。</p>
<p>JavaScript 中的数组,严格来说应该称作对象,是特殊的 JavaScript 对象,在内部被归类为数组。</p>
<h4 id="链表（Linked）"><a href="#链表（Linked）" class="headerlink" title="链表（Linked）"></a>链表（Linked）</h4><p>链表 [Linked List]：链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。即物理存储结构上不必连续，逻辑顺序是通过链表中的引用链接次序。</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/5l.jpg"></p>
<h4 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h4><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First in First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/6l.jpg"></p>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 (Stack)"></a>栈 (Stack)</h4><p>栈是限制插入与删除操作只能在末端 (Top) 进行的表，而这个末端也称为栈顶；栈是一种先进后出 (Last In First Out) 的线性表，简称 LIFO;</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/7l.jpg"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>顺序表</tag>
        <tag>链表</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>JS直接选择排序</title>
    <url>/algorithm/JS%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>第一次从待排序的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</p>
<h2 id="JS-实现代码："><a href="#JS-实现代码：" class="headerlink" title="JS 实现代码："></a>JS 实现代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = [<span class="number">14</span>, <span class="number">64</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">29</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T(n): O(n^2)</span></span><br><span class="line"><span class="comment"> * S(n): O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> selection = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">    j,</span><br><span class="line">    k,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; array.length) &#123;</span><br><span class="line">    j = i;</span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; array.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[k] &gt; array[j]) &#123;</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">      temp = array[i];</span><br><span class="line">      array[i] = array[k];</span><br><span class="line">      array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(selection(age)); <span class="comment">// [5, 7, 13, 14, 24,29, 34, 45, 51, 64]</span></span><br></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
]]></content>
      <categories>
        <category>JS算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>选择</tag>
      </tags>
  </entry>
  <entry>
    <title>JS希尔(shell)排序</title>
    <url>/algorithm/JS%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="演示图："><a href="#演示图：" class="headerlink" title="演示图："></a>演示图：</h2><p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/3.gif"></p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>希尔排序本质是插入排序。在插入排序的基础上提出了分组的概念。通过增量分组，对每组数据进行插入排序，然后缩小增量，重复对每组进行插入排序，直到增量缩小为 1 时，即对整个数据进行直接插入排序，排序完成。故 Shell 排序又称作缩小增量排序。Shell 排序的执行时间依赖于增量序列。</p>
<p>对一个有 15 个元素的数组进行 shell 排序，可先取一个增量序列（例如：5,3,1）将一串需排序的数列先按照 5 分组，每组三个数。对每组三个数进行排序。接下来按照 3 分组，每组五个数。对每组五个数进行排序。接下来是 1 也就是进行直接插入排序。</p>
<h2 id="增量分组原理："><a href="#增量分组原理：" class="headerlink" title="增量分组原理："></a>增量分组原理：</h2><p>假定数组：[1,3,2,6,4,5,9,7,8]，数组长度为 9，增量可设置为小于 9 的大于 0 的数值。如第一个增量，可设置为 5，则索引为 0 的元素 1 与索引为 0+5 的元素 5 以及索引为 0+n<em>5 的元素（如果存在的话）被分为一组，索引为 1+n</em>5 的元素被分为一组，依次类推。</p>
<h2 id="JS-代码实现："><a href="#JS-代码实现：" class="headerlink" title="JS 代码实现："></a>JS 代码实现：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = [<span class="number">14</span>, <span class="number">64</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">29</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T(n): O(n^1.5)</span></span><br><span class="line"><span class="comment"> * S(n): O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> shell = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">    j,</span><br><span class="line">    len = array.length,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i + gap &lt; len) &#123;</span><br><span class="line">      j = i;</span><br><span class="line">      <span class="keyword">while</span> (j + gap &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt;= array[j + gap]) &#123;</span><br><span class="line">          j = j + gap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          temp = array[j];</span><br><span class="line">          array[j] = array[j + gap];</span><br><span class="line">          array[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    gap = gap == <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">Math</span>.ceil(gap / <span class="number">2</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(shell(age)); <span class="comment">// [ 5, 7, 13, 14, 24, 29, 34, 45, 51, 64]</span></span><br></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><strong>优点</strong>：</p>
<p>空间复杂度较好，O(1)；作为改进版的插入排序，是一种相对高效的基于交换元素的排序方法。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>不稳定，在交换的过程中，会改变元素的相对次序。</li>
<li>希尔排序的时间复杂度依赖于增量序列函数，所以分析起来比较困难，当 n 在某个特定范围的时候，希尔排序的时间复杂度约为 O(n1.3)</li>
</ol>
<p>时间复杂度： O(n1.3)-O(n2)</p>
<p>根据增量序列的不同，shell 排序的时间复杂度也不同。</p>
<p>空间复杂度: O(1)</p>
]]></content>
      <categories>
        <category>JS算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>Shell</tag>
        <tag>希尔</tag>
      </tags>
  </entry>
  <entry>
    <title>JS直接插入排序</title>
    <url>/algorithm/JS%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动</p>
<h2 id="js-实现代码："><a href="#js-实现代码：" class="headerlink" title="js 实现代码："></a>js 实现代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = [<span class="number">14</span>, <span class="number">64</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">29</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T(n): O(n^2)</span></span><br><span class="line"><span class="comment"> * S(n): O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insertion = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>,</span><br><span class="line">    j;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; array.length) &#123;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &lt;= array[i]) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        array.splice(j, <span class="number">0</span>, array.splice(i, <span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(insertion(age)); <span class="comment">// [5, 7, 13, 14, 24, 29, 34, 45, 51, 64]</span></span><br></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
]]></content>
      <categories>
        <category>JS算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>JS冒泡排序</title>
    <url>/algorithm/JS%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>遍历要排序的元素列，一次比较相邻的两个元素，如果顺序错误就互换位置，重复进行此步骤，直到排序完成</p>
<h2 id="JS-实现代码："><a href="#JS-实现代码：" class="headerlink" title="JS 实现代码："></a>JS 实现代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = [<span class="number">14</span>, <span class="number">64</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">29</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T(n): O(n^2)</span></span><br><span class="line"><span class="comment"> * S(n): O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bubble0 = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length - <span class="number">1</span>,</span><br><span class="line">    i,</span><br><span class="line">    j,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="comment">// let count = 0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// count++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(count) // 10,10,10,10,10,10,10,10,10,10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bubble0(age)); <span class="comment">// [5, 7, 13, 14, 24, 24, 29, 34, 45, 51, 64]</span></span><br></pre></td></tr></table></figure>
<h2 id="JS-优化代码："><a href="#JS-优化代码：" class="headerlink" title="JS 优化代码："></a>JS 优化代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = [<span class="number">14</span>, <span class="number">64</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">29</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T(n): O(n^2)</span></span><br><span class="line"><span class="comment"> * S(n): O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bubble1 = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len1 = arr.length - <span class="number">1</span>,</span><br><span class="line">    len2 = len1,</span><br><span class="line">    i,</span><br><span class="line">    j,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len1 - <span class="number">1</span>; j++, len2--) &#123;</span><br><span class="line">    <span class="comment">// let count = 0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// count++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(count) // 10,9,8,7,6,5,4,3,2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bubble1(age)); <span class="comment">// [5, 7, 13, 14, 24, 24, 29, 34, 45, 51, 64]</span></span><br></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(n2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
]]></content>
      <categories>
        <category>JS算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>冒泡</tag>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法的基础概念</title>
    <url>/algorithm/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><p>一种方法，用于处理数据=》用于处理数据的一种方法</p>
<p>往上：算法是一种处理问题的思维方式</p>
<p>往下：算法就是解决问题的步骤</p>
<h2 id="算法必须具备的重要属性："><a href="#算法必须具备的重要属性：" class="headerlink" title="算法必须具备的重要属性："></a>算法必须具备的重要属性：</h2><ol>
<li>输入 : 算法具有 0 个或多个输入</li>
<li>输出 : 算法至少有 1 个或多个输出</li>
<li>有穷性 : 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</li>
<li>确定性 ：算法中的每一步都有确定的含义，不会出现二义性</li>
<li>可行性 ：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</li>
</ol>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>解释：算法复杂度是指算法在编写成可执行程序后，运行时所需要的时间资源和内存资源</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="时间频度："><a href="#时间频度：" class="headerlink" title="时间频度："></a>时间频度：</h3><p>一个算法中的代码语句需要执行的次数称为语句频度，并且一个算法花费的时间与算法中语句的执行次数成正比例，故语句频度又称为时间频度，记为 <strong>T(n)</strong></p>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>**T(n)**中的 n 表示算法实际处理的数据的规模大小，n 越大，则 T(n)越大。时间复杂度就用来表示，T(n)随 n 变化的规律，可表示为：T(n) = O(f(n))，则称 O(f(n))为算法的渐进时间复杂度，简称时间复杂度。</p>
<blockquote>
<p>注：上面公式中用到的 Landau 符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其 1892 年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。<strong>**Landau 符号的作用在于用简单的函数来描述复杂函数行为，给出一个****上或下（确）界**</strong>。在计算算法复杂度时一般只用到大<strong>O</strong>符号，Landau 符号体系中的小<strong>o</strong>符号、<strong>Θ</strong>符号等等比较不常用。这里的<strong>O</strong>，最初是用大写希腊字母，但现在都用大写英语字母<strong>O</strong>；小<strong>o</strong>符号也是用小写英语字母<strong>o</strong>，<strong>Θ</strong>符号则维持大写希腊字母<strong>Θ</strong>。</p>
<p><strong>T (n) = Ο(f (n))</strong> 表示存在一个常数 C，使得在当 n 趋于正无穷时总有 T (n) ≤ C * f(n)。简单来说，就是 T(n)在 n 趋于正无穷时最大也就跟 f(n)差不多大。也就是说当 n 趋于正无穷时<strong>T (n)**的上界是</strong>C * f(n)。<strong>其虽然对 f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2<em>n</em>2+n +1) = O (3<em>n</em>2+n+3) = O (7<em>n\</em>2 + n) = *<em>O ( \</em>n*2 )</strong> ，一般都只用*<em>O(\</em>n*2)**表示就可以了。注意到大 O 符号里隐藏着一个常数 C，所以 f(n)里一般不加系数。如果把 T(n)当做一棵树，那么 O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。</p>
</blockquote>
<h3 id="常见的时间复杂度有："><a href="#常见的时间复杂度有：" class="headerlink" title="常见的时间复杂度有："></a>常见的时间复杂度有：</h3><p><strong>复杂度依次升高</strong></p>
<ol>
<li>常数阶<strong>O(1)</strong> 哈希</li>
<li>对数阶<strong>O(**log*2n***)</strong></li>
<li>线性阶<strong>O(n)</strong></li>
<li>线性对数阶<strong>O(**n******lo**g*2n***)</strong></li>
<li>平方阶<strong>O(*n*2)</strong></li>
<li>立方阶<strong>O(*n*3)</strong>,</li>
<li>…</li>
<li>k 次方阶<strong>O(*n*k)</strong></li>
<li>指数阶<strong>O(*2*n)</strong></li>
</ol>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/1.png"></p>
<p>参考：<a href="https://www.jianshu.com/p/88a1c8ed6254">https://www.jianshu.com/p/88a1c8ed6254</a></p>
<h3 id="求解算法的时间复杂度"><a href="#求解算法的时间复杂度" class="headerlink" title="求解算法的时间复杂度"></a><strong>求解算法的时间复杂度</strong></h3><h4 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h4><p>（1）找出算法中重复执行次数最多的语句的频度来估算算法的时间复杂度；</p>
<p>（2）保留算法的最高次幂，忽略所有低次幂和高次幂的系数；</p>
<p>（3）将算法执行次数的数量级放入大 Ο 记号中。</p>
<h4 id="规律："><a href="#规律：" class="headerlink" title="规律："></a>规律：</h4><ol>
<li>基本操作，即只有常数项，认为其时间复杂度为 O(1)</li>
<li>顺序结构，时间复杂度按加法进行计算</li>
<li>循环结构，时间复杂度按乘法进行计算</li>
<li>分支结构，时间复杂度取最大值</li>
<li>判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略</li>
<li>在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度</li>
</ol>
<h4 id="分析技巧："><a href="#分析技巧：" class="headerlink" title="*分析技巧："></a>*分析技巧：</h4><ol>
<li>有几重循环，一般来说一重就是 O(n)，两重就是 O(n^2),以此类推</li>
<li>如果循环中有二分，则为 O(logN)</li>
<li>保留最高项，去除常数项</li>
</ol>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，是对一个算法在运行过程中临时占用存储空间大小的量度，用 S(n)表示，</p>
<p>常用空间复杂度有：O(1)、O(n)、O(n²)</p>
<h1 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h1><p>排序过程中，相等元素在排序后位置不变为稳定。若位置可能改变则为不稳定的。</p>
<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><ol>
<li>排序算法：冒泡、快速、插入、选择、希尔、归并、堆、计数、桶、基数</li>
<li>查找算法：顺序、二分、插值、树、斐波那契、分块、哈希</li>
<li>加密算法：<br>a. 对称加密：DES、3DES、AES<br>b. 非对称加密：RSA、DSA</li>
<li>散列算法：SHA-1、MD5</li>
</ol>
]]></content>
      <categories>
        <category>JS算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>复杂度</tag>
        <tag>空间复杂度</tag>
        <tag>时间复杂度</tag>
        <tag>时间频度</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs生成UID</title>
    <url>/NodeJs/nodejs%E7%94%9F%E6%88%90UID/</url>
    <content><![CDATA[<h2 id="nodejs-生成-UID（唯一标识符）"><a href="#nodejs-生成-UID（唯一标识符）" class="headerlink" title="nodejs 生成 UID（唯一标识符）"></a>nodejs 生成 UID（唯一标识符）</h2><p><strong>——node-uuid 模块用于生成用户 id</strong></p>
<h3 id="安装-uuid-模块"><a href="#安装-uuid-模块" class="headerlink" title="安装 uuid 模块"></a>安装 uuid 模块</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install uuid --save</span><br></pre></td></tr></table></figure>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="v1：基于时间戳"><a href="#v1：基于时间戳" class="headerlink" title="v1：基于时间戳"></a>v1：基于时间戳</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId1 = uuid.v1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uuidv1 = <span class="built_in">require</span>(<span class="string">&quot;uuid/v1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId2 = uuidv1();</span><br></pre></td></tr></table></figure>
<h4 id="v3：基于命名空间"><a href="#v3：基于命名空间" class="headerlink" title="v3：基于命名空间"></a>v3：基于命名空间</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId1 = uuid.v3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uuidv3 = <span class="built_in">require</span>(<span class="string">&quot;uuid/v3&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId2 = uuidv3();</span><br></pre></td></tr></table></figure>
<h4 id="v4：随机"><a href="#v4：随机" class="headerlink" title="v4：随机"></a>v4：随机</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId1 = uuid.v4();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uuidv4 = <span class="built_in">require</span>(<span class="string">&quot;uuid/v4&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId1 = uuidv4();</span><br></pre></td></tr></table></figure>
<h4 id="v5：-基于名字的-UUID（SHA1）"><a href="#v5：-基于名字的-UUID（SHA1）" class="headerlink" title="v5： 基于名字的 UUID（SHA1）"></a>v5： 基于名字的 UUID（SHA1）</h4><p>类似 v3，只是散列算法使用 SHA1 算法, v3 使用 hash 算法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId1 = uuid.v5();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uuidv5 = <span class="built_in">require</span>(<span class="string">&quot;uuid/v5&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId1 = uuidv5();</span><br></pre></td></tr></table></figure>
<p>文档： <a href="https://github.com/uuidjs/uuid">https://github.com/uuidjs/uuid</a></p>
<p>参考： <a href="https://blog.csdn.net/nawenqiang/article/details/82684001">https://blog.csdn.net/nawenqiang/article/details/82684001</a></p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>uuid</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>JS获取剪切板图片并显示到页面上</title>
    <url>/JS%E8%AF%AD%E6%B3%95/JS%E8%8E%B7%E5%8F%96%E5%89%AA%E5%88%87%E6%9D%BF%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是有序列表01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是有序列表02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是有序列表03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是有序列表04<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是有序列表05<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是有序列表06<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 监听粘贴事件 paste</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;paste&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取clipboardData对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> &#123; items &#125; = e.clipboardData;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (items) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 判断粘贴板数据是否为图片</span></span></span><br><span class="line"><span class="javascript">          [...items].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (v.type.indexOf(<span class="string">&quot;image&quot;</span>) == -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//获取图片内容</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> file = v.getAsFile();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 读取图片文件</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> render = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 读取为data: URL格式的Base64字符串</span></span></span><br><span class="line">            render.readAsDataURL(file);</span><br><span class="line"><span class="javascript">            <span class="comment">// 读取完成时触发</span></span></span><br><span class="line"><span class="javascript">            render.onload = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 获取base64 串</span></span></span><br><span class="line"><span class="javascript">              <span class="keyword">var</span> base64_str = event.target.result;</span></span><br><span class="line">              img.src = base64_str;</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h2><p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/copyboard.png"></p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>剪切板</tag>
        <tag>FileReader</tag>
        <tag>clipboardData</tag>
        <tag>paste事件</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数据属性和访问器属性</title>
    <url>/JS%E8%AF%AD%E6%B3%95/JS%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="什么是数据属性和访问器属性？"><a href="#什么是数据属性和访问器属性？" class="headerlink" title="什么是数据属性和访问器属性？"></a>什么是数据属性和访问器属性？</h2><p>对 js 对象属性进行增删改查的方法，刚接触 js 的人都会：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 增</span><br><span class="line">obj.name &#x3D; &#39;lonzisng&#39;</span><br><span class="line">obj.pwd &#x3D; &#39;123&#39;</span><br><span class="line">&#x2F;&#x2F; 删</span><br><span class="line">delete obj.pwd</span><br><span class="line">&#x2F;&#x2F; 改</span><br><span class="line">obj.name &#x3D; &#39;归谷&#39;</span><br><span class="line">&#x2F;&#x2F; 查</span><br><span class="line">obj.name  &#x2F;&#x2F; &#39;归谷&#39;</span><br></pre></td></tr></table></figure>
<p>以上的 name 和 pwd 属性都是 obj 对象的数据属性。</p>
<blockquote>
<p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值。</p>
</blockquote>
<p>即是说，<strong>对象中存有值的属性，都可以认为是数据属性。</strong></p>
<p>数据属性有 4 个描述其行为的特性，我理解为操作对象属性的基本权限，分别对应了对属性操作的增删改查：</p>
<ul>
<li>[[configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为 true</li>
<li>[[enumerable]]：表示能否通过 for-in 循环返回属性 ，默认为 true</li>
<li>[[writable]]：表示能否修改属性的值 ，默认为 true</li>
<li>[[value]]：包含该属性的数据值，默认为 undefined</li>
</ul>
<p>而想要更改这些特性，在 ES5 之前是不可能的，至今也只有 ES5 中提供 Object.defineProperty()方法和 Object.defineProperties() 两个方法才可以修改这些特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user &#x3D; &#123;type: 0&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给user对象指定可遍历不可删除并只读的属性type</span><br><span class="line">Object.defineProperty(user, &#39;type&#39;, &#123;</span><br><span class="line">    value: &#39;admin&#39;,</span><br><span class="line">    writable: false,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(user.type)  &#x2F;&#x2F;admin</span><br><span class="line">user.type &#x3D; &#39;lonzisng&#39;</span><br><span class="line">console.log(user.type)  &#x2F;&#x2F; admin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object.defineProperties(user, &#123;</span><br><span class="line">  &#39;name&#39;: &#123;</span><br><span class="line">    value: &#39;lonzisng&#39;,</span><br><span class="line">    writable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#39;age&#39;: &#123;</span><br><span class="line">    value: 18,</span><br><span class="line">    writable: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Object.defineProperty()方法接受三个参数，第一个参数为需要修改属性的对象，第二个参数为需要修改的属性名，第三个参数为描述特性的对象（对象中只能有 configurable、enumerable、writable 和 value 四个特性值中的一个或多个）。</p>
<p>Object.defineProperties()方法则只接受两个参数，第一个为需要修改属性的对象，第二个为多个属性及其特性组成的对象。</p>
<p>而除了修改之外，ES5 还提供要给查看接口 Object.getOwnPropertyDescriptor()，可以用来查看对象的某一属性当前的特性情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name: &#39;lonzisng&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(obj, &#39;name&#39;));  &#x2F;&#x2F; &#123;value: &#39;lonzisng&#39;, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问器属性不包含数据值，而主要是包含一对 getter 和 setter 函数</strong>，并且这两个函数都不是必须的。</p>
<blockquote>
<p>顾名思义，在读取访问器属性时，会调用 getter 函数，由 getter 函数负责返回有效的值，在写入访问器属性时，会调用 setter 函数去传入新的值，并由 setter 函数来决定如何处理这个值。</p>
</blockquote>
<p>访问器属性，同样由四个特性来控制属性的操作：</p>
<ul>
<li>[[configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为 false</li>
<li>[[enumerable]]：表示能否通过 for-in 循环返回属性，默认为 false</li>
<li>[[Get]]：在读取属性时调用的函数，默认值为 undefined</li>
<li>[[Set]]：在写入属性时调用的函数，默认值为 undefined</li>
</ul>
<p>访问器属性同样需要使用 Object.defineProperties()方法 来修改这些特性，以下是一个经典示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var book &#x3D; &#123;</span><br><span class="line">    __year: 2019,</span><br><span class="line">    edition: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperties(book, &#39;year&#39;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return this.__year</span><br><span class="line">    &#125;,</span><br><span class="line">    set() &#123;</span><br><span class="line">        if (newValue &gt; 2019) &#123;</span><br><span class="line">            this.__year &#x3D; newValue</span><br><span class="line">            this.edition +&#x3D; newValue - 2019</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.year &#x3D; 2020</span><br><span class="line">alert( book.edition ) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p>当我们在给 year 属性赋值 2020 时，调用 set()方法&gt;判断 2020 ＞ 2019，执行 if 内部代码，得到的结果为__year 的值变为 2020，edition 的值变为 2。</p>
<p>Object.definePropertise()方法同样支持访问器属性。</p>
<p>访问器属性可以起到很好的保护作用，当只有 get 方法时，就实现只读不能写；反之，只有 set 时，便是只能写入而不能读取</p>
<h2 id="这些特性都被用在了什么地方？"><a href="#这些特性都被用在了什么地方？" class="headerlink" title="这些特性都被用在了什么地方？"></a>这些特性都被用在了什么地方？</h2><h3 id="订阅者发布者模式"><a href="#订阅者发布者模式" class="headerlink" title="订阅者发布者模式"></a>订阅者发布者模式</h3><p>发布者通过 Object.defineProperty() 来劫持各个属性的 setter，getter，将数据变动发送给订阅者</p>
<h3 id="vue-双向数据绑定"><a href="#vue-双向数据绑定" class="headerlink" title="vue 双向数据绑定"></a>vue 双向数据绑定</h3><p>vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。</p>
]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>数据属性</tag>
        <tag>访问器</tag>
        <tag>defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类数组</title>
    <url>/JS%E8%AF%AD%E6%B3%95/JS%E7%B1%BB%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="什么是类数组"><a href="#什么是类数组" class="headerlink" title="什么是类数组"></a>什么是类数组</h2><blockquote>
<p>1、类数组其实是一个对象</p>
<p>2、这个对象的属性的键名为大于等于零的整数</p>
<p>3、这个对象具有 length 属性，且 length 属性的值为大于零的整数</p>
</blockquote>
<p>一般只要具备上诉条件，就可以称为类数组，也称为类数组对象，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let aObj &#x3D; &#123;</span><br><span class="line">    0: &#39;张三&#39;,</span><br><span class="line">    1: &#39;18岁&#39;,</span><br><span class="line">    2: &#39;主站 lonzisng.wang&#39;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，这个 aObj 就是一个类数组了。</p>
<p><strong>一般我们常见的类数组有：</strong></p>
<ul>
<li>参数列表 <code>arguments</code></li>
<li>节点列表 <code>nodeList</code> (通过 DOM 操作获取的元素节点列表)</li>
</ul>
<h2 id="类数组与数组的区别"><a href="#类数组与数组的区别" class="headerlink" title="类数组与数组的区别"></a>类数组与数组的区别</h2><ol>
<li>类数组一般没有或者只实现了部分数组的方法</li>
<li>类数组是实际是对象，所以可以通过添加方法的方式为其添加数组方法，如 push、pop、shift 等等</li>
<li>类数组可以使用 for 循环遍历，但在为单独设置时，不能使用 forEach、map 等数组方法遍历</li>
</ol>
<h2 id="有意思的点"><a href="#有意思的点" class="headerlink" title="有意思的点"></a>有意思的点</h2><p>在 chrome 中，使用前面的代码创建出的类数组打印显示如图：</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/lsz1.png"></p>
<p>但是当给这个类数组加上<code>splice</code>方法后，</p>
<p><img src="https://gitee.com/six-u/gallery/raw/master/wallpaper/lsz2.png"></p>
<p>控制台中的表示竟然从 ｛｝ 变为了 []，好像真的变为了数组一样，而且只有当加入了 splice 方法后才会有这种效果。当然这只是一种错觉。(<strong>也有说法认为此时的对象才是真正的类数组对象</strong>)</p>
<h2 id="将类数组转换为数组"><a href="#将类数组转换为数组" class="headerlink" title="将类数组转换为数组"></a>将类数组转换为数组</h2><p>1、使用 call() 调用数组的方法，使目标类数组对象可以使用 Array 上的方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; Array.prototype.slice.call(aObj)</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 &#x3D; Array.prototype.splice.call(aObj,0,aObj.length)</span><br></pre></td></tr></table></figure>
<p>2、使用 Array.from()方法，此方法处于 ES6，其作用为将类数组或者具有遍历器接口的类型转换成一个真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; Array.from(aObj)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS语法</category>
      </categories>
      <tags>
        <tag>类数组</tag>
        <tag>数组</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs使用mySQL链接池</title>
    <url>/NodeJs/nodejs%E4%BD%BF%E7%94%A8mySQL%E9%93%BE%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="使用-MySQL-模块"><a href="#使用-MySQL-模块" class="headerlink" title="使用 MySQL 模块"></a>使用 MySQL 模块</h2><p>安装： <code>npm install mysql</code></p>
<p>引入：<code>const mysql = require(&#39;mysql&#39;)</code></p>
<h2 id="单个链接"><a href="#单个链接" class="headerlink" title="单个链接"></a>单个链接</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="keyword">var</span> connection =  mysql.createConnection(&#123;</span><br><span class="line">   host : “hostName”,</span><br><span class="line">   user : “username”,</span><br><span class="line">   password: “password”</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 建立一个新的链接</span></span><br><span class="line">connection.connect();</span><br><span class="line"><span class="comment">// 选则数据库</span></span><br><span class="line">connection.query(“use database1”);</span><br><span class="line"><span class="comment">// 编写sql语句</span></span><br><span class="line"><span class="keyword">var</span> sql = “select * <span class="keyword">from</span> table1”;</span><br><span class="line"><span class="comment">// 使用链接进行访问</span></span><br><span class="line">connection.query( sql, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( rows );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.sqlpool = <span class="function">(<span class="params">sql, arr, callback</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>; <span class="comment">// 使用严格模式</span></span><br><span class="line">  <span class="keyword">let</span> pools = &#123;</span><br><span class="line">    config: &#123;</span><br><span class="line">      host: <span class="string">&quot;localhost&quot;</span>, <span class="comment">// 数据库地址</span></span><br><span class="line">      user: <span class="string">&quot;root&quot;</span>, <span class="comment">// 数据库账号</span></span><br><span class="line">      password: <span class="string">&quot;1230&quot;</span>, <span class="comment">// 数据库密码</span></span><br><span class="line">      port: <span class="number">3306</span>, <span class="comment">// 端口号</span></span><br><span class="line">      database: <span class="string">&quot;bms&quot;</span>, <span class="comment">// 选择库</span></span><br><span class="line">    &#125;,</span><br><span class="line">    qurey: <span class="function">(<span class="params">sql, arr, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pool = mysql.createPool(pools.config); <span class="comment">// 创建连接池</span></span><br><span class="line">      pool.getConnection(<span class="function">(<span class="params">err, connect</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//并发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">          connect.query(sql, arr, callback);</span><br><span class="line">          connect.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  pools.qurey(sql, arr, callback); <span class="comment">// 发送请求</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>nodejs</tag>
        <tag>链接池</tag>
      </tags>
  </entry>
</search>
