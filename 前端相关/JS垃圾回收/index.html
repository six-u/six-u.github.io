<!DOCTYPE html><html lang="en" manifest="/sixu.appcache"><head><meta charset="utf-8"><meta name="keywords" content="web, 前端, JS, Vue"><meta name="description" content="技术没有边界，人也没有"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>JS垃圾回收 | SixU 煦之</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script src="/js/pace.min.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body><main class="content"><section class="outer"><article id="post-前端相关/JS垃圾回收" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">JS垃圾回收</h1></header><div class="article-meta"><a href="/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date"><time datetime="2021-05-19T15:08:21.000Z" itemprop="datePublished">2021-05-19</time></a><div class="article-category"><a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/">前端相关</a></div></div><div class="tocbot"></div><div class="article-entry" itemprop="articleBody"><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a><strong>内存泄露</strong></h2><p>程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。所以，<strong>对于不再用到的内存，没有及时释放，就叫做<a target="_blank" rel="noopener" href="https://six-u.gitee.io/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存泄漏</a></strong></p><h2 id="什么是垃圾回收？"><a href="#什么是垃圾回收？" class="headerlink" title="什么是垃圾回收？"></a><strong>什么是垃圾回收？</strong></h2><p>不再继续使用的变量就是垃圾，垃圾还占用着内存造成内存泄露，所以垃圾需要回收，也就是不使用的内存需要回收以便之后使用。所以<strong>垃圾回收是一种内存管理机制</strong>。垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存</p><h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a><strong>js的垃圾回收机制</strong></h2><p>Javascript 具有自动垃圾回收机制 (GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。</p><p>JavaScript 垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p><h2 id="js垃圾回收原理"><a href="#js垃圾回收原理" class="headerlink" title="js垃圾回收原理"></a><strong>js垃圾回收原理</strong></h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="*标记清除"></a>*<strong>标记清除</strong></h3><p><strong>原理：</strong>当变量进入执行环境（如在函数中声明一个变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量</p><p><strong>绝大多数现代浏览器使用此方式进行垃圾回收。</strong></p><p><strong>执行过程</strong>：JavaScript 中有个全局对象，浏览器中是 window。垃圾收集器将定期从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象，一直进行下去，并对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。</p><p>标记阶段</p><p><img src="https://gitee.com/six-u/gallery/raw/master/biaoji.png"></p><p>清除阶段</p><p><img src="https://gitee.com/six-u/gallery/raw/master/clearprocess.png"></p><p><strong>缺点：</strong></p><ol><li>标记的效率太慢了，我们的垃圾回收需要时时刻刻去遍历检查每一个引用，如果你的js代码中对象太多，会导致非常严重的效率问题</li><li>浏览器在标记的过程中js是不能执行的，我们不能让垃圾回收拖慢我们js运行的时间</li></ol><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="*引用计数"></a>*<strong>引用计数</strong></h3><p>机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。</p><p>这种方式常常会引起内存泄漏（循环引用时），低版本的IE使用这种方式</p><p><img src="https://gitee.com/six-u/gallery/raw/master/yinyongjs.png"></p><p><strong>缺点：</strong></p><ol><li>A 和 B 循环引用，就算没有其他地方引用A或B,A/B的计时器都至少为1，不会被回收，造成内存泄露</li><li>变量的计数器一直计数，所以需要一直占用一定的空间，直到变量被回收，增加了内容占用</li></ol><p><img src="https://gitee.com/six-u/gallery/raw/master/xunhuanyinyong.png"></p><h2 id="js垃圾回收（标记清除）相关优化"><a href="#js垃圾回收（标记清除）相关优化" class="headerlink" title="js垃圾回收（标记清除）相关优化"></a><strong>js垃圾回收（标记清除）相关优化</strong></h2><h3 id="分代回收（Generation-GC）："><a href="#分代回收（Generation-GC）：" class="headerlink" title="分代回收（Generation GC）："></a><strong>分代回收（Generation GC）：</strong></h3><p>通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时</p><p>例如：V8将内存分为新生代和老生代，新生代中对象存活时间较短；老生代的对象存活时间较长或常驻内存</p><p><strong>Scavenge 算法</strong>：在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收。</p><p><strong>Cheney算法</strong>：Scavenge 算法的主要内部实现，Cheney 算法将堆内存一分为二，一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间。分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，将其复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理。还有一种情况是，如果复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中。</p><p><img src="https://gitee.com/six-u/gallery/raw/master/cheneysca.png"></p><p><strong>标记-清除和标记-整理算法：</strong>在分代的基础上，对老生代使用此算法。标记清楚后会留下不连续的内存空间，使用标记整理解决这一问题。<strong>标记-整理**</strong>由于需要移动对象，执行速度不会太快，所以在取舍上，V8主要使用**<strong>标记-清除**</strong>，当内存不足以分配时才会采用**<strong>标记-整理</strong></p><p><img src="https://gitee.com/six-u/gallery/raw/master/markcompase.png"></p><h3 id="增量标记-GC"><a href="#增量标记-GC" class="headerlink" title="增量标记 GC"></a><strong>增量标记 GC</strong></h3><p>全停顿（stop-the-world）：</p><p>为了避免js应用逻辑和垃圾回收器看到不一样的情况，前面三种垃圾回收算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑。这种行为被称为全停顿。</p><p>在上述V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代恰恰相反，全停顿很肯能导致页面卡顿。</p><p>所以，为了降低全堆垃圾回收带来的停顿时间，V8在标记时采用增量标记（incremental marking），即<strong>将标记拆分为许多小步进，每一个步进完成时，就让js逻辑执行一小会</strong>。<strong>垃圾回收和逻辑执行交替进行，直到标记阶段完成</strong>。而后续的清理和整理也分别采用延迟清理（lazy sweeping）和增量整理（incremental compact</p><p><img src="https://gitee.com/six-u/gallery/raw/master/incremental_marking.png"></p><p>参考：</p><blockquote><p>​ <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113296268">v8垃圾回收机制</a></p><p>​ <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23992332">JavaScript 中的垃圾回收</a></p><p>​ <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353346756">浅析JS垃圾回收机制</a></p><p>​ <a target="_blank" rel="noopener" href="https://www.jb51.net/article/162416.htm">深入理解 JS 垃圾回收</a></p></blockquote></div><footer class="article-footer"><a data-url="http://six-u.github.io/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="cks7lkrsq002bpofecca5e2vp" class="article-share-link">分享</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag-list/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" rel="tag">内存泄漏</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag-list/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag">垃圾回收</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag-list/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/" rel="tag">引用计数</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag-list/%E6%A0%87%E8%AE%B0%E6%B8%85%E6%A5%9A/" rel="tag">标记清楚</a></li></ul></footer></div><div class="vcomments" id="vcomments"></div><script src="https://unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"geSruNdqLwsDxJSjaAmTiSQR-gzGzoHsz",appKey:"LmoURXO6RVhvCmEe2TBxdo8I",notify:"false",verify:"true",avatar:"mp",pageSize:"10",placeholder:"请输入..."})</script></article></section><footer class="footer" id="footer"><div class="outer"><div class="float-right"><ul class="list-inline"><li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li><li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li></ul></div><ul class="list-inline"><li>SixU 煦之 &copy; 2021</li></ul></div></footer></main><aside class="sidebar"><button class="navbar-toggle"></button><nav class="navbar"><div class="logo"><a href="/"><img src="/images/logo-s.png" alt="SixU  煦之"></a></div><ul class="nav nav-main"><li class="nav-item"><a class="nav-item-link" href="/index">首页</a></li><li class="nav-item"><a class="nav-item-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/">分类</a></li><li class="nav-item"><a class="nav-item-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-item-link" href="/muxia/">木下</a></li><li class="nav-item"><a class="nav-item-link" href="/about/">关于</a></li><li class="nav-item terminal"><a class="nav-item-link" href="/simpleConsole.html"><i class="fe fe-terminal"></i> Ter</a></li><li class="nav-item"><a class="nav-item-link" href="https://github.com/six-u" target="_blank"><i class="fe fe-github"></i> Github</a></li><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="fe fe-search"></i> 搜索</a></li><li class="nav-item"><a target="_blank" rel="noopener" href="https://sixu-test.myshopify.com/" title="搜索"><i class="fe fe-search"></i> ddd</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><div class="totop" id="totop"><i class="fe fe-rocket"></i></div></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"><input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/busuanzi-2.3.pure.min.js"></script><script src="/js/tocbot.min.js"></script><script>tocbot.init({tocSelector:".tocbot",contentSelector:".article-entry",headingSelector:"h1, h2, h3, h4, h5, h6",hasInnerContainers:!0,scrollSmooth:!0,positionFixedSelector:".tocbot",positionFixedClass:"is-position-fixed",fixedSidebarOffset:"auto"})</script><script src="/js/ocean.js"></script></body></html>